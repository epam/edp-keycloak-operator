// Code generated by mockery v2.43.0. DO NOT EDIT.

package mocks

import (
	context "context"

	adapter "github.com/epam/edp-keycloak-operator/pkg/client/keycloak/adapter"

	dto "github.com/epam/edp-keycloak-operator/pkg/client/keycloak/dto"

	gocloak "github.com/Nerzal/gocloak/v12"

	mock "github.com/stretchr/testify/mock"

	v1 "github.com/epam/edp-keycloak-operator/api/v1"
)

// MockClient is an autogenerated mock type for the Client type
type MockClient struct {
	mock.Mock
}

type MockClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockClient) EXPECT() *MockClient_Expecter {
	return &MockClient_Expecter{mock: &_m.Mock}
}

// AddClientRoleToUser provides a mock function with given fields: realmName, clientId, user, role
func (_m *MockClient) AddClientRoleToUser(realmName string, clientId string, user *dto.User, role string) error {
	ret := _m.Called(realmName, clientId, user, role)

	if len(ret) == 0 {
		panic("no return value specified for AddClientRoleToUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, *dto.User, string) error); ok {
		r0 = rf(realmName, clientId, user, role)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_AddClientRoleToUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddClientRoleToUser'
type MockClient_AddClientRoleToUser_Call struct {
	*mock.Call
}

// AddClientRoleToUser is a helper method to define mock.On call
//   - realmName string
//   - clientId string
//   - user *dto.User
//   - role string
func (_e *MockClient_Expecter) AddClientRoleToUser(realmName interface{}, clientId interface{}, user interface{}, role interface{}) *MockClient_AddClientRoleToUser_Call {
	return &MockClient_AddClientRoleToUser_Call{Call: _e.mock.On("AddClientRoleToUser", realmName, clientId, user, role)}
}

func (_c *MockClient_AddClientRoleToUser_Call) Run(run func(realmName string, clientId string, user *dto.User, role string)) *MockClient_AddClientRoleToUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(*dto.User), args[3].(string))
	})
	return _c
}

func (_c *MockClient_AddClientRoleToUser_Call) Return(_a0 error) *MockClient_AddClientRoleToUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_AddClientRoleToUser_Call) RunAndReturn(run func(string, string, *dto.User, string) error) *MockClient_AddClientRoleToUser_Call {
	_c.Call.Return(run)
	return _c
}

// AddDefaultScopeToClient provides a mock function with given fields: ctx, realmName, clientName, scopes
func (_m *MockClient) AddDefaultScopeToClient(ctx context.Context, realmName string, clientName string, scopes []adapter.ClientScope) error {
	ret := _m.Called(ctx, realmName, clientName, scopes)

	if len(ret) == 0 {
		panic("no return value specified for AddDefaultScopeToClient")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []adapter.ClientScope) error); ok {
		r0 = rf(ctx, realmName, clientName, scopes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_AddDefaultScopeToClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddDefaultScopeToClient'
type MockClient_AddDefaultScopeToClient_Call struct {
	*mock.Call
}

// AddDefaultScopeToClient is a helper method to define mock.On call
//   - ctx context.Context
//   - realmName string
//   - clientName string
//   - scopes []adapter.ClientScope
func (_e *MockClient_Expecter) AddDefaultScopeToClient(ctx interface{}, realmName interface{}, clientName interface{}, scopes interface{}) *MockClient_AddDefaultScopeToClient_Call {
	return &MockClient_AddDefaultScopeToClient_Call{Call: _e.mock.On("AddDefaultScopeToClient", ctx, realmName, clientName, scopes)}
}

func (_c *MockClient_AddDefaultScopeToClient_Call) Run(run func(ctx context.Context, realmName string, clientName string, scopes []adapter.ClientScope)) *MockClient_AddDefaultScopeToClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]adapter.ClientScope))
	})
	return _c
}

func (_c *MockClient_AddDefaultScopeToClient_Call) Return(_a0 error) *MockClient_AddDefaultScopeToClient_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_AddDefaultScopeToClient_Call) RunAndReturn(run func(context.Context, string, string, []adapter.ClientScope) error) *MockClient_AddDefaultScopeToClient_Call {
	_c.Call.Return(run)
	return _c
}

// AddRealmRoleToUser provides a mock function with given fields: ctx, realmName, username, roleName
func (_m *MockClient) AddRealmRoleToUser(ctx context.Context, realmName string, username string, roleName string) error {
	ret := _m.Called(ctx, realmName, username, roleName)

	if len(ret) == 0 {
		panic("no return value specified for AddRealmRoleToUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, realmName, username, roleName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_AddRealmRoleToUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddRealmRoleToUser'
type MockClient_AddRealmRoleToUser_Call struct {
	*mock.Call
}

// AddRealmRoleToUser is a helper method to define mock.On call
//   - ctx context.Context
//   - realmName string
//   - username string
//   - roleName string
func (_e *MockClient_Expecter) AddRealmRoleToUser(ctx interface{}, realmName interface{}, username interface{}, roleName interface{}) *MockClient_AddRealmRoleToUser_Call {
	return &MockClient_AddRealmRoleToUser_Call{Call: _e.mock.On("AddRealmRoleToUser", ctx, realmName, username, roleName)}
}

func (_c *MockClient_AddRealmRoleToUser_Call) Run(run func(ctx context.Context, realmName string, username string, roleName string)) *MockClient_AddRealmRoleToUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockClient_AddRealmRoleToUser_Call) Return(_a0 error) *MockClient_AddRealmRoleToUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_AddRealmRoleToUser_Call) RunAndReturn(run func(context.Context, string, string, string) error) *MockClient_AddRealmRoleToUser_Call {
	_c.Call.Return(run)
	return _c
}

// CreateClient provides a mock function with given fields: ctx, client
func (_m *MockClient) CreateClient(ctx context.Context, client *dto.Client) error {
	ret := _m.Called(ctx, client)

	if len(ret) == 0 {
		panic("no return value specified for CreateClient")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *dto.Client) error); ok {
		r0 = rf(ctx, client)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_CreateClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateClient'
type MockClient_CreateClient_Call struct {
	*mock.Call
}

// CreateClient is a helper method to define mock.On call
//   - ctx context.Context
//   - client *dto.Client
func (_e *MockClient_Expecter) CreateClient(ctx interface{}, client interface{}) *MockClient_CreateClient_Call {
	return &MockClient_CreateClient_Call{Call: _e.mock.On("CreateClient", ctx, client)}
}

func (_c *MockClient_CreateClient_Call) Run(run func(ctx context.Context, client *dto.Client)) *MockClient_CreateClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*dto.Client))
	})
	return _c
}

func (_c *MockClient_CreateClient_Call) Return(_a0 error) *MockClient_CreateClient_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_CreateClient_Call) RunAndReturn(run func(context.Context, *dto.Client) error) *MockClient_CreateClient_Call {
	_c.Call.Return(run)
	return _c
}

// CreateClientRole provides a mock function with given fields: role, clientRole
func (_m *MockClient) CreateClientRole(role *dto.Client, clientRole string) error {
	ret := _m.Called(role, clientRole)

	if len(ret) == 0 {
		panic("no return value specified for CreateClientRole")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*dto.Client, string) error); ok {
		r0 = rf(role, clientRole)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_CreateClientRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateClientRole'
type MockClient_CreateClientRole_Call struct {
	*mock.Call
}

// CreateClientRole is a helper method to define mock.On call
//   - role *dto.Client
//   - clientRole string
func (_e *MockClient_Expecter) CreateClientRole(role interface{}, clientRole interface{}) *MockClient_CreateClientRole_Call {
	return &MockClient_CreateClientRole_Call{Call: _e.mock.On("CreateClientRole", role, clientRole)}
}

func (_c *MockClient_CreateClientRole_Call) Run(run func(role *dto.Client, clientRole string)) *MockClient_CreateClientRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*dto.Client), args[1].(string))
	})
	return _c
}

func (_c *MockClient_CreateClientRole_Call) Return(_a0 error) *MockClient_CreateClientRole_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_CreateClientRole_Call) RunAndReturn(run func(*dto.Client, string) error) *MockClient_CreateClientRole_Call {
	_c.Call.Return(run)
	return _c
}

// CreateClientScope provides a mock function with given fields: ctx, realmName, scope
func (_m *MockClient) CreateClientScope(ctx context.Context, realmName string, scope *adapter.ClientScope) (string, error) {
	ret := _m.Called(ctx, realmName, scope)

	if len(ret) == 0 {
		panic("no return value specified for CreateClientScope")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *adapter.ClientScope) (string, error)); ok {
		return rf(ctx, realmName, scope)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *adapter.ClientScope) string); ok {
		r0 = rf(ctx, realmName, scope)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *adapter.ClientScope) error); ok {
		r1 = rf(ctx, realmName, scope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_CreateClientScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateClientScope'
type MockClient_CreateClientScope_Call struct {
	*mock.Call
}

// CreateClientScope is a helper method to define mock.On call
//   - ctx context.Context
//   - realmName string
//   - scope *adapter.ClientScope
func (_e *MockClient_Expecter) CreateClientScope(ctx interface{}, realmName interface{}, scope interface{}) *MockClient_CreateClientScope_Call {
	return &MockClient_CreateClientScope_Call{Call: _e.mock.On("CreateClientScope", ctx, realmName, scope)}
}

func (_c *MockClient_CreateClientScope_Call) Run(run func(ctx context.Context, realmName string, scope *adapter.ClientScope)) *MockClient_CreateClientScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*adapter.ClientScope))
	})
	return _c
}

func (_c *MockClient_CreateClientScope_Call) Return(_a0 string, _a1 error) *MockClient_CreateClientScope_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_CreateClientScope_Call) RunAndReturn(run func(context.Context, string, *adapter.ClientScope) (string, error)) *MockClient_CreateClientScope_Call {
	_c.Call.Return(run)
	return _c
}

// CreateComponent provides a mock function with given fields: ctx, realmName, component
func (_m *MockClient) CreateComponent(ctx context.Context, realmName string, component *adapter.Component) error {
	ret := _m.Called(ctx, realmName, component)

	if len(ret) == 0 {
		panic("no return value specified for CreateComponent")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *adapter.Component) error); ok {
		r0 = rf(ctx, realmName, component)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_CreateComponent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateComponent'
type MockClient_CreateComponent_Call struct {
	*mock.Call
}

// CreateComponent is a helper method to define mock.On call
//   - ctx context.Context
//   - realmName string
//   - component *adapter.Component
func (_e *MockClient_Expecter) CreateComponent(ctx interface{}, realmName interface{}, component interface{}) *MockClient_CreateComponent_Call {
	return &MockClient_CreateComponent_Call{Call: _e.mock.On("CreateComponent", ctx, realmName, component)}
}

func (_c *MockClient_CreateComponent_Call) Run(run func(ctx context.Context, realmName string, component *adapter.Component)) *MockClient_CreateComponent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*adapter.Component))
	})
	return _c
}

func (_c *MockClient_CreateComponent_Call) Return(_a0 error) *MockClient_CreateComponent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_CreateComponent_Call) RunAndReturn(run func(context.Context, string, *adapter.Component) error) *MockClient_CreateComponent_Call {
	_c.Call.Return(run)
	return _c
}

// CreateIDPMapper provides a mock function with given fields: ctx, realm, idpAlias, mapper
func (_m *MockClient) CreateIDPMapper(ctx context.Context, realm string, idpAlias string, mapper *adapter.IdentityProviderMapper) (string, error) {
	ret := _m.Called(ctx, realm, idpAlias, mapper)

	if len(ret) == 0 {
		panic("no return value specified for CreateIDPMapper")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *adapter.IdentityProviderMapper) (string, error)); ok {
		return rf(ctx, realm, idpAlias, mapper)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *adapter.IdentityProviderMapper) string); ok {
		r0 = rf(ctx, realm, idpAlias, mapper)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *adapter.IdentityProviderMapper) error); ok {
		r1 = rf(ctx, realm, idpAlias, mapper)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_CreateIDPMapper_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateIDPMapper'
type MockClient_CreateIDPMapper_Call struct {
	*mock.Call
}

// CreateIDPMapper is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idpAlias string
//   - mapper *adapter.IdentityProviderMapper
func (_e *MockClient_Expecter) CreateIDPMapper(ctx interface{}, realm interface{}, idpAlias interface{}, mapper interface{}) *MockClient_CreateIDPMapper_Call {
	return &MockClient_CreateIDPMapper_Call{Call: _e.mock.On("CreateIDPMapper", ctx, realm, idpAlias, mapper)}
}

func (_c *MockClient_CreateIDPMapper_Call) Run(run func(ctx context.Context, realm string, idpAlias string, mapper *adapter.IdentityProviderMapper)) *MockClient_CreateIDPMapper_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*adapter.IdentityProviderMapper))
	})
	return _c
}

func (_c *MockClient_CreateIDPMapper_Call) Return(_a0 string, _a1 error) *MockClient_CreateIDPMapper_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_CreateIDPMapper_Call) RunAndReturn(run func(context.Context, string, string, *adapter.IdentityProviderMapper) (string, error)) *MockClient_CreateIDPMapper_Call {
	_c.Call.Return(run)
	return _c
}

// CreateIdentityProvider provides a mock function with given fields: ctx, realm, idp
func (_m *MockClient) CreateIdentityProvider(ctx context.Context, realm string, idp *adapter.IdentityProvider) error {
	ret := _m.Called(ctx, realm, idp)

	if len(ret) == 0 {
		panic("no return value specified for CreateIdentityProvider")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *adapter.IdentityProvider) error); ok {
		r0 = rf(ctx, realm, idp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_CreateIdentityProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateIdentityProvider'
type MockClient_CreateIdentityProvider_Call struct {
	*mock.Call
}

// CreateIdentityProvider is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idp *adapter.IdentityProvider
func (_e *MockClient_Expecter) CreateIdentityProvider(ctx interface{}, realm interface{}, idp interface{}) *MockClient_CreateIdentityProvider_Call {
	return &MockClient_CreateIdentityProvider_Call{Call: _e.mock.On("CreateIdentityProvider", ctx, realm, idp)}
}

func (_c *MockClient_CreateIdentityProvider_Call) Run(run func(ctx context.Context, realm string, idp *adapter.IdentityProvider)) *MockClient_CreateIdentityProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*adapter.IdentityProvider))
	})
	return _c
}

func (_c *MockClient_CreateIdentityProvider_Call) Return(_a0 error) *MockClient_CreateIdentityProvider_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_CreateIdentityProvider_Call) RunAndReturn(run func(context.Context, string, *adapter.IdentityProvider) error) *MockClient_CreateIdentityProvider_Call {
	_c.Call.Return(run)
	return _c
}

// CreateIncludedRealmRole provides a mock function with given fields: realmName, role
func (_m *MockClient) CreateIncludedRealmRole(realmName string, role *dto.IncludedRealmRole) error {
	ret := _m.Called(realmName, role)

	if len(ret) == 0 {
		panic("no return value specified for CreateIncludedRealmRole")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *dto.IncludedRealmRole) error); ok {
		r0 = rf(realmName, role)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_CreateIncludedRealmRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateIncludedRealmRole'
type MockClient_CreateIncludedRealmRole_Call struct {
	*mock.Call
}

// CreateIncludedRealmRole is a helper method to define mock.On call
//   - realmName string
//   - role *dto.IncludedRealmRole
func (_e *MockClient_Expecter) CreateIncludedRealmRole(realmName interface{}, role interface{}) *MockClient_CreateIncludedRealmRole_Call {
	return &MockClient_CreateIncludedRealmRole_Call{Call: _e.mock.On("CreateIncludedRealmRole", realmName, role)}
}

func (_c *MockClient_CreateIncludedRealmRole_Call) Run(run func(realmName string, role *dto.IncludedRealmRole)) *MockClient_CreateIncludedRealmRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*dto.IncludedRealmRole))
	})
	return _c
}

func (_c *MockClient_CreateIncludedRealmRole_Call) Return(_a0 error) *MockClient_CreateIncludedRealmRole_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_CreateIncludedRealmRole_Call) RunAndReturn(run func(string, *dto.IncludedRealmRole) error) *MockClient_CreateIncludedRealmRole_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePermission provides a mock function with given fields: ctx, realm, idOfClient, permission
func (_m *MockClient) CreatePermission(ctx context.Context, realm string, idOfClient string, permission gocloak.PermissionRepresentation) (*gocloak.PermissionRepresentation, error) {
	ret := _m.Called(ctx, realm, idOfClient, permission)

	if len(ret) == 0 {
		panic("no return value specified for CreatePermission")
	}

	var r0 *gocloak.PermissionRepresentation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.PermissionRepresentation) (*gocloak.PermissionRepresentation, error)); ok {
		return rf(ctx, realm, idOfClient, permission)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.PermissionRepresentation) *gocloak.PermissionRepresentation); ok {
		r0 = rf(ctx, realm, idOfClient, permission)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.PermissionRepresentation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.PermissionRepresentation) error); ok {
		r1 = rf(ctx, realm, idOfClient, permission)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_CreatePermission_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePermission'
type MockClient_CreatePermission_Call struct {
	*mock.Call
}

// CreatePermission is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idOfClient string
//   - permission gocloak.PermissionRepresentation
func (_e *MockClient_Expecter) CreatePermission(ctx interface{}, realm interface{}, idOfClient interface{}, permission interface{}) *MockClient_CreatePermission_Call {
	return &MockClient_CreatePermission_Call{Call: _e.mock.On("CreatePermission", ctx, realm, idOfClient, permission)}
}

func (_c *MockClient_CreatePermission_Call) Run(run func(ctx context.Context, realm string, idOfClient string, permission gocloak.PermissionRepresentation)) *MockClient_CreatePermission_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(gocloak.PermissionRepresentation))
	})
	return _c
}

func (_c *MockClient_CreatePermission_Call) Return(_a0 *gocloak.PermissionRepresentation, _a1 error) *MockClient_CreatePermission_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_CreatePermission_Call) RunAndReturn(run func(context.Context, string, string, gocloak.PermissionRepresentation) (*gocloak.PermissionRepresentation, error)) *MockClient_CreatePermission_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePolicy provides a mock function with given fields: ctx, realm, idOfClient, policy
func (_m *MockClient) CreatePolicy(ctx context.Context, realm string, idOfClient string, policy gocloak.PolicyRepresentation) (*gocloak.PolicyRepresentation, error) {
	ret := _m.Called(ctx, realm, idOfClient, policy)

	if len(ret) == 0 {
		panic("no return value specified for CreatePolicy")
	}

	var r0 *gocloak.PolicyRepresentation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.PolicyRepresentation) (*gocloak.PolicyRepresentation, error)); ok {
		return rf(ctx, realm, idOfClient, policy)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.PolicyRepresentation) *gocloak.PolicyRepresentation); ok {
		r0 = rf(ctx, realm, idOfClient, policy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.PolicyRepresentation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, gocloak.PolicyRepresentation) error); ok {
		r1 = rf(ctx, realm, idOfClient, policy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_CreatePolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePolicy'
type MockClient_CreatePolicy_Call struct {
	*mock.Call
}

// CreatePolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idOfClient string
//   - policy gocloak.PolicyRepresentation
func (_e *MockClient_Expecter) CreatePolicy(ctx interface{}, realm interface{}, idOfClient interface{}, policy interface{}) *MockClient_CreatePolicy_Call {
	return &MockClient_CreatePolicy_Call{Call: _e.mock.On("CreatePolicy", ctx, realm, idOfClient, policy)}
}

func (_c *MockClient_CreatePolicy_Call) Run(run func(ctx context.Context, realm string, idOfClient string, policy gocloak.PolicyRepresentation)) *MockClient_CreatePolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(gocloak.PolicyRepresentation))
	})
	return _c
}

func (_c *MockClient_CreatePolicy_Call) Return(_a0 *gocloak.PolicyRepresentation, _a1 error) *MockClient_CreatePolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_CreatePolicy_Call) RunAndReturn(run func(context.Context, string, string, gocloak.PolicyRepresentation) (*gocloak.PolicyRepresentation, error)) *MockClient_CreatePolicy_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePrimaryRealmRole provides a mock function with given fields: ctx, realmName, role
func (_m *MockClient) CreatePrimaryRealmRole(ctx context.Context, realmName string, role *dto.PrimaryRealmRole) (string, error) {
	ret := _m.Called(ctx, realmName, role)

	if len(ret) == 0 {
		panic("no return value specified for CreatePrimaryRealmRole")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *dto.PrimaryRealmRole) (string, error)); ok {
		return rf(ctx, realmName, role)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *dto.PrimaryRealmRole) string); ok {
		r0 = rf(ctx, realmName, role)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *dto.PrimaryRealmRole) error); ok {
		r1 = rf(ctx, realmName, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_CreatePrimaryRealmRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePrimaryRealmRole'
type MockClient_CreatePrimaryRealmRole_Call struct {
	*mock.Call
}

// CreatePrimaryRealmRole is a helper method to define mock.On call
//   - ctx context.Context
//   - realmName string
//   - role *dto.PrimaryRealmRole
func (_e *MockClient_Expecter) CreatePrimaryRealmRole(ctx interface{}, realmName interface{}, role interface{}) *MockClient_CreatePrimaryRealmRole_Call {
	return &MockClient_CreatePrimaryRealmRole_Call{Call: _e.mock.On("CreatePrimaryRealmRole", ctx, realmName, role)}
}

func (_c *MockClient_CreatePrimaryRealmRole_Call) Run(run func(ctx context.Context, realmName string, role *dto.PrimaryRealmRole)) *MockClient_CreatePrimaryRealmRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*dto.PrimaryRealmRole))
	})
	return _c
}

func (_c *MockClient_CreatePrimaryRealmRole_Call) Return(_a0 string, _a1 error) *MockClient_CreatePrimaryRealmRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_CreatePrimaryRealmRole_Call) RunAndReturn(run func(context.Context, string, *dto.PrimaryRealmRole) (string, error)) *MockClient_CreatePrimaryRealmRole_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRealmUser provides a mock function with given fields: realmName, user
func (_m *MockClient) CreateRealmUser(realmName string, user *dto.User) error {
	ret := _m.Called(realmName, user)

	if len(ret) == 0 {
		panic("no return value specified for CreateRealmUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *dto.User) error); ok {
		r0 = rf(realmName, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_CreateRealmUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRealmUser'
type MockClient_CreateRealmUser_Call struct {
	*mock.Call
}

// CreateRealmUser is a helper method to define mock.On call
//   - realmName string
//   - user *dto.User
func (_e *MockClient_Expecter) CreateRealmUser(realmName interface{}, user interface{}) *MockClient_CreateRealmUser_Call {
	return &MockClient_CreateRealmUser_Call{Call: _e.mock.On("CreateRealmUser", realmName, user)}
}

func (_c *MockClient_CreateRealmUser_Call) Run(run func(realmName string, user *dto.User)) *MockClient_CreateRealmUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*dto.User))
	})
	return _c
}

func (_c *MockClient_CreateRealmUser_Call) Return(_a0 error) *MockClient_CreateRealmUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_CreateRealmUser_Call) RunAndReturn(run func(string, *dto.User) error) *MockClient_CreateRealmUser_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRealmWithDefaultConfig provides a mock function with given fields: realm
func (_m *MockClient) CreateRealmWithDefaultConfig(realm *dto.Realm) error {
	ret := _m.Called(realm)

	if len(ret) == 0 {
		panic("no return value specified for CreateRealmWithDefaultConfig")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*dto.Realm) error); ok {
		r0 = rf(realm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_CreateRealmWithDefaultConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRealmWithDefaultConfig'
type MockClient_CreateRealmWithDefaultConfig_Call struct {
	*mock.Call
}

// CreateRealmWithDefaultConfig is a helper method to define mock.On call
//   - realm *dto.Realm
func (_e *MockClient_Expecter) CreateRealmWithDefaultConfig(realm interface{}) *MockClient_CreateRealmWithDefaultConfig_Call {
	return &MockClient_CreateRealmWithDefaultConfig_Call{Call: _e.mock.On("CreateRealmWithDefaultConfig", realm)}
}

func (_c *MockClient_CreateRealmWithDefaultConfig_Call) Run(run func(realm *dto.Realm)) *MockClient_CreateRealmWithDefaultConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*dto.Realm))
	})
	return _c
}

func (_c *MockClient_CreateRealmWithDefaultConfig_Call) Return(_a0 error) *MockClient_CreateRealmWithDefaultConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_CreateRealmWithDefaultConfig_Call) RunAndReturn(run func(*dto.Realm) error) *MockClient_CreateRealmWithDefaultConfig_Call {
	_c.Call.Return(run)
	return _c
}

// CreateScope provides a mock function with given fields: ctx, realm, idOfClient, scope
func (_m *MockClient) CreateScope(ctx context.Context, realm string, idOfClient string, scope string) (*gocloak.ScopeRepresentation, error) {
	ret := _m.Called(ctx, realm, idOfClient, scope)

	if len(ret) == 0 {
		panic("no return value specified for CreateScope")
	}

	var r0 *gocloak.ScopeRepresentation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (*gocloak.ScopeRepresentation, error)); ok {
		return rf(ctx, realm, idOfClient, scope)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *gocloak.ScopeRepresentation); ok {
		r0 = rf(ctx, realm, idOfClient, scope)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ScopeRepresentation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, realm, idOfClient, scope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_CreateScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateScope'
type MockClient_CreateScope_Call struct {
	*mock.Call
}

// CreateScope is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idOfClient string
//   - scope string
func (_e *MockClient_Expecter) CreateScope(ctx interface{}, realm interface{}, idOfClient interface{}, scope interface{}) *MockClient_CreateScope_Call {
	return &MockClient_CreateScope_Call{Call: _e.mock.On("CreateScope", ctx, realm, idOfClient, scope)}
}

func (_c *MockClient_CreateScope_Call) Run(run func(ctx context.Context, realm string, idOfClient string, scope string)) *MockClient_CreateScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockClient_CreateScope_Call) Return(_a0 *gocloak.ScopeRepresentation, _a1 error) *MockClient_CreateScope_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_CreateScope_Call) RunAndReturn(run func(context.Context, string, string, string) (*gocloak.ScopeRepresentation, error)) *MockClient_CreateScope_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAuthFlow provides a mock function with given fields: realmName, flow
func (_m *MockClient) DeleteAuthFlow(realmName string, flow *adapter.KeycloakAuthFlow) error {
	ret := _m.Called(realmName, flow)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAuthFlow")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *adapter.KeycloakAuthFlow) error); ok {
		r0 = rf(realmName, flow)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DeleteAuthFlow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAuthFlow'
type MockClient_DeleteAuthFlow_Call struct {
	*mock.Call
}

// DeleteAuthFlow is a helper method to define mock.On call
//   - realmName string
//   - flow *adapter.KeycloakAuthFlow
func (_e *MockClient_Expecter) DeleteAuthFlow(realmName interface{}, flow interface{}) *MockClient_DeleteAuthFlow_Call {
	return &MockClient_DeleteAuthFlow_Call{Call: _e.mock.On("DeleteAuthFlow", realmName, flow)}
}

func (_c *MockClient_DeleteAuthFlow_Call) Run(run func(realmName string, flow *adapter.KeycloakAuthFlow)) *MockClient_DeleteAuthFlow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*adapter.KeycloakAuthFlow))
	})
	return _c
}

func (_c *MockClient_DeleteAuthFlow_Call) Return(_a0 error) *MockClient_DeleteAuthFlow_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DeleteAuthFlow_Call) RunAndReturn(run func(string, *adapter.KeycloakAuthFlow) error) *MockClient_DeleteAuthFlow_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteClient provides a mock function with given fields: ctx, kcClientID, realmName
func (_m *MockClient) DeleteClient(ctx context.Context, kcClientID string, realmName string) error {
	ret := _m.Called(ctx, kcClientID, realmName)

	if len(ret) == 0 {
		panic("no return value specified for DeleteClient")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, kcClientID, realmName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DeleteClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteClient'
type MockClient_DeleteClient_Call struct {
	*mock.Call
}

// DeleteClient is a helper method to define mock.On call
//   - ctx context.Context
//   - kcClientID string
//   - realmName string
func (_e *MockClient_Expecter) DeleteClient(ctx interface{}, kcClientID interface{}, realmName interface{}) *MockClient_DeleteClient_Call {
	return &MockClient_DeleteClient_Call{Call: _e.mock.On("DeleteClient", ctx, kcClientID, realmName)}
}

func (_c *MockClient_DeleteClient_Call) Run(run func(ctx context.Context, kcClientID string, realmName string)) *MockClient_DeleteClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_DeleteClient_Call) Return(_a0 error) *MockClient_DeleteClient_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DeleteClient_Call) RunAndReturn(run func(context.Context, string, string) error) *MockClient_DeleteClient_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteClientScope provides a mock function with given fields: ctx, realmName, scopeID
func (_m *MockClient) DeleteClientScope(ctx context.Context, realmName string, scopeID string) error {
	ret := _m.Called(ctx, realmName, scopeID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteClientScope")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, realmName, scopeID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DeleteClientScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteClientScope'
type MockClient_DeleteClientScope_Call struct {
	*mock.Call
}

// DeleteClientScope is a helper method to define mock.On call
//   - ctx context.Context
//   - realmName string
//   - scopeID string
func (_e *MockClient_Expecter) DeleteClientScope(ctx interface{}, realmName interface{}, scopeID interface{}) *MockClient_DeleteClientScope_Call {
	return &MockClient_DeleteClientScope_Call{Call: _e.mock.On("DeleteClientScope", ctx, realmName, scopeID)}
}

func (_c *MockClient_DeleteClientScope_Call) Run(run func(ctx context.Context, realmName string, scopeID string)) *MockClient_DeleteClientScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_DeleteClientScope_Call) Return(_a0 error) *MockClient_DeleteClientScope_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DeleteClientScope_Call) RunAndReturn(run func(context.Context, string, string) error) *MockClient_DeleteClientScope_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteComponent provides a mock function with given fields: ctx, realmName, componentName
func (_m *MockClient) DeleteComponent(ctx context.Context, realmName string, componentName string) error {
	ret := _m.Called(ctx, realmName, componentName)

	if len(ret) == 0 {
		panic("no return value specified for DeleteComponent")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, realmName, componentName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DeleteComponent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteComponent'
type MockClient_DeleteComponent_Call struct {
	*mock.Call
}

// DeleteComponent is a helper method to define mock.On call
//   - ctx context.Context
//   - realmName string
//   - componentName string
func (_e *MockClient_Expecter) DeleteComponent(ctx interface{}, realmName interface{}, componentName interface{}) *MockClient_DeleteComponent_Call {
	return &MockClient_DeleteComponent_Call{Call: _e.mock.On("DeleteComponent", ctx, realmName, componentName)}
}

func (_c *MockClient_DeleteComponent_Call) Run(run func(ctx context.Context, realmName string, componentName string)) *MockClient_DeleteComponent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_DeleteComponent_Call) Return(_a0 error) *MockClient_DeleteComponent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DeleteComponent_Call) RunAndReturn(run func(context.Context, string, string) error) *MockClient_DeleteComponent_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGroup provides a mock function with given fields: ctx, realm, groupName
func (_m *MockClient) DeleteGroup(ctx context.Context, realm string, groupName string) error {
	ret := _m.Called(ctx, realm, groupName)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGroup")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, realm, groupName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DeleteGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGroup'
type MockClient_DeleteGroup_Call struct {
	*mock.Call
}

// DeleteGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - groupName string
func (_e *MockClient_Expecter) DeleteGroup(ctx interface{}, realm interface{}, groupName interface{}) *MockClient_DeleteGroup_Call {
	return &MockClient_DeleteGroup_Call{Call: _e.mock.On("DeleteGroup", ctx, realm, groupName)}
}

func (_c *MockClient_DeleteGroup_Call) Run(run func(ctx context.Context, realm string, groupName string)) *MockClient_DeleteGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_DeleteGroup_Call) Return(_a0 error) *MockClient_DeleteGroup_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DeleteGroup_Call) RunAndReturn(run func(context.Context, string, string) error) *MockClient_DeleteGroup_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteIDPMapper provides a mock function with given fields: ctx, realm, idpAlias, mapperID
func (_m *MockClient) DeleteIDPMapper(ctx context.Context, realm string, idpAlias string, mapperID string) error {
	ret := _m.Called(ctx, realm, idpAlias, mapperID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIDPMapper")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, realm, idpAlias, mapperID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DeleteIDPMapper_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteIDPMapper'
type MockClient_DeleteIDPMapper_Call struct {
	*mock.Call
}

// DeleteIDPMapper is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idpAlias string
//   - mapperID string
func (_e *MockClient_Expecter) DeleteIDPMapper(ctx interface{}, realm interface{}, idpAlias interface{}, mapperID interface{}) *MockClient_DeleteIDPMapper_Call {
	return &MockClient_DeleteIDPMapper_Call{Call: _e.mock.On("DeleteIDPMapper", ctx, realm, idpAlias, mapperID)}
}

func (_c *MockClient_DeleteIDPMapper_Call) Run(run func(ctx context.Context, realm string, idpAlias string, mapperID string)) *MockClient_DeleteIDPMapper_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockClient_DeleteIDPMapper_Call) Return(_a0 error) *MockClient_DeleteIDPMapper_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DeleteIDPMapper_Call) RunAndReturn(run func(context.Context, string, string, string) error) *MockClient_DeleteIDPMapper_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteIdentityProvider provides a mock function with given fields: ctx, realm, alias
func (_m *MockClient) DeleteIdentityProvider(ctx context.Context, realm string, alias string) error {
	ret := _m.Called(ctx, realm, alias)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIdentityProvider")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, realm, alias)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DeleteIdentityProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteIdentityProvider'
type MockClient_DeleteIdentityProvider_Call struct {
	*mock.Call
}

// DeleteIdentityProvider is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - alias string
func (_e *MockClient_Expecter) DeleteIdentityProvider(ctx interface{}, realm interface{}, alias interface{}) *MockClient_DeleteIdentityProvider_Call {
	return &MockClient_DeleteIdentityProvider_Call{Call: _e.mock.On("DeleteIdentityProvider", ctx, realm, alias)}
}

func (_c *MockClient_DeleteIdentityProvider_Call) Run(run func(ctx context.Context, realm string, alias string)) *MockClient_DeleteIdentityProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_DeleteIdentityProvider_Call) Return(_a0 error) *MockClient_DeleteIdentityProvider_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DeleteIdentityProvider_Call) RunAndReturn(run func(context.Context, string, string) error) *MockClient_DeleteIdentityProvider_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePermission provides a mock function with given fields: ctx, realm, idOfClient, permissionID
func (_m *MockClient) DeletePermission(ctx context.Context, realm string, idOfClient string, permissionID string) error {
	ret := _m.Called(ctx, realm, idOfClient, permissionID)

	if len(ret) == 0 {
		panic("no return value specified for DeletePermission")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, realm, idOfClient, permissionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DeletePermission_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePermission'
type MockClient_DeletePermission_Call struct {
	*mock.Call
}

// DeletePermission is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idOfClient string
//   - permissionID string
func (_e *MockClient_Expecter) DeletePermission(ctx interface{}, realm interface{}, idOfClient interface{}, permissionID interface{}) *MockClient_DeletePermission_Call {
	return &MockClient_DeletePermission_Call{Call: _e.mock.On("DeletePermission", ctx, realm, idOfClient, permissionID)}
}

func (_c *MockClient_DeletePermission_Call) Run(run func(ctx context.Context, realm string, idOfClient string, permissionID string)) *MockClient_DeletePermission_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockClient_DeletePermission_Call) Return(_a0 error) *MockClient_DeletePermission_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DeletePermission_Call) RunAndReturn(run func(context.Context, string, string, string) error) *MockClient_DeletePermission_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePolicy provides a mock function with given fields: ctx, realm, idOfClient, policyID
func (_m *MockClient) DeletePolicy(ctx context.Context, realm string, idOfClient string, policyID string) error {
	ret := _m.Called(ctx, realm, idOfClient, policyID)

	if len(ret) == 0 {
		panic("no return value specified for DeletePolicy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, realm, idOfClient, policyID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DeletePolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePolicy'
type MockClient_DeletePolicy_Call struct {
	*mock.Call
}

// DeletePolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idOfClient string
//   - policyID string
func (_e *MockClient_Expecter) DeletePolicy(ctx interface{}, realm interface{}, idOfClient interface{}, policyID interface{}) *MockClient_DeletePolicy_Call {
	return &MockClient_DeletePolicy_Call{Call: _e.mock.On("DeletePolicy", ctx, realm, idOfClient, policyID)}
}

func (_c *MockClient_DeletePolicy_Call) Run(run func(ctx context.Context, realm string, idOfClient string, policyID string)) *MockClient_DeletePolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockClient_DeletePolicy_Call) Return(_a0 error) *MockClient_DeletePolicy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DeletePolicy_Call) RunAndReturn(run func(context.Context, string, string, string) error) *MockClient_DeletePolicy_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRealm provides a mock function with given fields: ctx, realmName
func (_m *MockClient) DeleteRealm(ctx context.Context, realmName string) error {
	ret := _m.Called(ctx, realmName)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRealm")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, realmName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DeleteRealm_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRealm'
type MockClient_DeleteRealm_Call struct {
	*mock.Call
}

// DeleteRealm is a helper method to define mock.On call
//   - ctx context.Context
//   - realmName string
func (_e *MockClient_Expecter) DeleteRealm(ctx interface{}, realmName interface{}) *MockClient_DeleteRealm_Call {
	return &MockClient_DeleteRealm_Call{Call: _e.mock.On("DeleteRealm", ctx, realmName)}
}

func (_c *MockClient_DeleteRealm_Call) Run(run func(ctx context.Context, realmName string)) *MockClient_DeleteRealm_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_DeleteRealm_Call) Return(_a0 error) *MockClient_DeleteRealm_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DeleteRealm_Call) RunAndReturn(run func(context.Context, string) error) *MockClient_DeleteRealm_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRealmRole provides a mock function with given fields: ctx, realm, roleName
func (_m *MockClient) DeleteRealmRole(ctx context.Context, realm string, roleName string) error {
	ret := _m.Called(ctx, realm, roleName)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRealmRole")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, realm, roleName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DeleteRealmRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRealmRole'
type MockClient_DeleteRealmRole_Call struct {
	*mock.Call
}

// DeleteRealmRole is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - roleName string
func (_e *MockClient_Expecter) DeleteRealmRole(ctx interface{}, realm interface{}, roleName interface{}) *MockClient_DeleteRealmRole_Call {
	return &MockClient_DeleteRealmRole_Call{Call: _e.mock.On("DeleteRealmRole", ctx, realm, roleName)}
}

func (_c *MockClient_DeleteRealmRole_Call) Run(run func(ctx context.Context, realm string, roleName string)) *MockClient_DeleteRealmRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_DeleteRealmRole_Call) Return(_a0 error) *MockClient_DeleteRealmRole_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DeleteRealmRole_Call) RunAndReturn(run func(context.Context, string, string) error) *MockClient_DeleteRealmRole_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRealmUser provides a mock function with given fields: ctx, realmName, username
func (_m *MockClient) DeleteRealmUser(ctx context.Context, realmName string, username string) error {
	ret := _m.Called(ctx, realmName, username)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRealmUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, realmName, username)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DeleteRealmUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRealmUser'
type MockClient_DeleteRealmUser_Call struct {
	*mock.Call
}

// DeleteRealmUser is a helper method to define mock.On call
//   - ctx context.Context
//   - realmName string
//   - username string
func (_e *MockClient_Expecter) DeleteRealmUser(ctx interface{}, realmName interface{}, username interface{}) *MockClient_DeleteRealmUser_Call {
	return &MockClient_DeleteRealmUser_Call{Call: _e.mock.On("DeleteRealmUser", ctx, realmName, username)}
}

func (_c *MockClient_DeleteRealmUser_Call) Run(run func(ctx context.Context, realmName string, username string)) *MockClient_DeleteRealmUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_DeleteRealmUser_Call) Return(_a0 error) *MockClient_DeleteRealmUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DeleteRealmUser_Call) RunAndReturn(run func(context.Context, string, string) error) *MockClient_DeleteRealmUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteScope provides a mock function with given fields: ctx, realm, idOfClient, scope
func (_m *MockClient) DeleteScope(ctx context.Context, realm string, idOfClient string, scope string) error {
	ret := _m.Called(ctx, realm, idOfClient, scope)

	if len(ret) == 0 {
		panic("no return value specified for DeleteScope")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, realm, idOfClient, scope)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DeleteScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteScope'
type MockClient_DeleteScope_Call struct {
	*mock.Call
}

// DeleteScope is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idOfClient string
//   - scope string
func (_e *MockClient_Expecter) DeleteScope(ctx interface{}, realm interface{}, idOfClient interface{}, scope interface{}) *MockClient_DeleteScope_Call {
	return &MockClient_DeleteScope_Call{Call: _e.mock.On("DeleteScope", ctx, realm, idOfClient, scope)}
}

func (_c *MockClient_DeleteScope_Call) Run(run func(ctx context.Context, realm string, idOfClient string, scope string)) *MockClient_DeleteScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockClient_DeleteScope_Call) Return(_a0 error) *MockClient_DeleteScope_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DeleteScope_Call) RunAndReturn(run func(context.Context, string, string, string) error) *MockClient_DeleteScope_Call {
	_c.Call.Return(run)
	return _c
}

// ExistClient provides a mock function with given fields: clientID, realm
func (_m *MockClient) ExistClient(clientID string, realm string) (bool, error) {
	ret := _m.Called(clientID, realm)

	if len(ret) == 0 {
		panic("no return value specified for ExistClient")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (bool, error)); ok {
		return rf(clientID, realm)
	}
	if rf, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = rf(clientID, realm)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(clientID, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_ExistClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistClient'
type MockClient_ExistClient_Call struct {
	*mock.Call
}

// ExistClient is a helper method to define mock.On call
//   - clientID string
//   - realm string
func (_e *MockClient_Expecter) ExistClient(clientID interface{}, realm interface{}) *MockClient_ExistClient_Call {
	return &MockClient_ExistClient_Call{Call: _e.mock.On("ExistClient", clientID, realm)}
}

func (_c *MockClient_ExistClient_Call) Run(run func(clientID string, realm string)) *MockClient_ExistClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockClient_ExistClient_Call) Return(_a0 bool, _a1 error) *MockClient_ExistClient_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_ExistClient_Call) RunAndReturn(run func(string, string) (bool, error)) *MockClient_ExistClient_Call {
	_c.Call.Return(run)
	return _c
}

// ExistClientRole provides a mock function with given fields: role, clientRole
func (_m *MockClient) ExistClientRole(role *dto.Client, clientRole string) (bool, error) {
	ret := _m.Called(role, clientRole)

	if len(ret) == 0 {
		panic("no return value specified for ExistClientRole")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*dto.Client, string) (bool, error)); ok {
		return rf(role, clientRole)
	}
	if rf, ok := ret.Get(0).(func(*dto.Client, string) bool); ok {
		r0 = rf(role, clientRole)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*dto.Client, string) error); ok {
		r1 = rf(role, clientRole)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_ExistClientRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistClientRole'
type MockClient_ExistClientRole_Call struct {
	*mock.Call
}

// ExistClientRole is a helper method to define mock.On call
//   - role *dto.Client
//   - clientRole string
func (_e *MockClient_Expecter) ExistClientRole(role interface{}, clientRole interface{}) *MockClient_ExistClientRole_Call {
	return &MockClient_ExistClientRole_Call{Call: _e.mock.On("ExistClientRole", role, clientRole)}
}

func (_c *MockClient_ExistClientRole_Call) Run(run func(role *dto.Client, clientRole string)) *MockClient_ExistClientRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*dto.Client), args[1].(string))
	})
	return _c
}

func (_c *MockClient_ExistClientRole_Call) Return(_a0 bool, _a1 error) *MockClient_ExistClientRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_ExistClientRole_Call) RunAndReturn(run func(*dto.Client, string) (bool, error)) *MockClient_ExistClientRole_Call {
	_c.Call.Return(run)
	return _c
}

// ExistRealm provides a mock function with given fields: realm
func (_m *MockClient) ExistRealm(realm string) (bool, error) {
	ret := _m.Called(realm)

	if len(ret) == 0 {
		panic("no return value specified for ExistRealm")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(realm)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(realm)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_ExistRealm_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistRealm'
type MockClient_ExistRealm_Call struct {
	*mock.Call
}

// ExistRealm is a helper method to define mock.On call
//   - realm string
func (_e *MockClient_Expecter) ExistRealm(realm interface{}) *MockClient_ExistRealm_Call {
	return &MockClient_ExistRealm_Call{Call: _e.mock.On("ExistRealm", realm)}
}

func (_c *MockClient_ExistRealm_Call) Run(run func(realm string)) *MockClient_ExistRealm_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockClient_ExistRealm_Call) Return(_a0 bool, _a1 error) *MockClient_ExistRealm_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_ExistRealm_Call) RunAndReturn(run func(string) (bool, error)) *MockClient_ExistRealm_Call {
	_c.Call.Return(run)
	return _c
}

// ExistRealmRole provides a mock function with given fields: realmName, roleName
func (_m *MockClient) ExistRealmRole(realmName string, roleName string) (bool, error) {
	ret := _m.Called(realmName, roleName)

	if len(ret) == 0 {
		panic("no return value specified for ExistRealmRole")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (bool, error)); ok {
		return rf(realmName, roleName)
	}
	if rf, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = rf(realmName, roleName)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(realmName, roleName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_ExistRealmRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistRealmRole'
type MockClient_ExistRealmRole_Call struct {
	*mock.Call
}

// ExistRealmRole is a helper method to define mock.On call
//   - realmName string
//   - roleName string
func (_e *MockClient_Expecter) ExistRealmRole(realmName interface{}, roleName interface{}) *MockClient_ExistRealmRole_Call {
	return &MockClient_ExistRealmRole_Call{Call: _e.mock.On("ExistRealmRole", realmName, roleName)}
}

func (_c *MockClient_ExistRealmRole_Call) Run(run func(realmName string, roleName string)) *MockClient_ExistRealmRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockClient_ExistRealmRole_Call) Return(_a0 bool, _a1 error) *MockClient_ExistRealmRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_ExistRealmRole_Call) RunAndReturn(run func(string, string) (bool, error)) *MockClient_ExistRealmRole_Call {
	_c.Call.Return(run)
	return _c
}

// ExistRealmUser provides a mock function with given fields: realmName, user
func (_m *MockClient) ExistRealmUser(realmName string, user *dto.User) (bool, error) {
	ret := _m.Called(realmName, user)

	if len(ret) == 0 {
		panic("no return value specified for ExistRealmUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *dto.User) (bool, error)); ok {
		return rf(realmName, user)
	}
	if rf, ok := ret.Get(0).(func(string, *dto.User) bool); ok {
		r0 = rf(realmName, user)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, *dto.User) error); ok {
		r1 = rf(realmName, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_ExistRealmUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistRealmUser'
type MockClient_ExistRealmUser_Call struct {
	*mock.Call
}

// ExistRealmUser is a helper method to define mock.On call
//   - realmName string
//   - user *dto.User
func (_e *MockClient_Expecter) ExistRealmUser(realmName interface{}, user interface{}) *MockClient_ExistRealmUser_Call {
	return &MockClient_ExistRealmUser_Call{Call: _e.mock.On("ExistRealmUser", realmName, user)}
}

func (_c *MockClient_ExistRealmUser_Call) Run(run func(realmName string, user *dto.User)) *MockClient_ExistRealmUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*dto.User))
	})
	return _c
}

func (_c *MockClient_ExistRealmUser_Call) Return(_a0 bool, _a1 error) *MockClient_ExistRealmUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_ExistRealmUser_Call) RunAndReturn(run func(string, *dto.User) (bool, error)) *MockClient_ExistRealmUser_Call {
	_c.Call.Return(run)
	return _c
}

// ExportToken provides a mock function with given fields:
func (_m *MockClient) ExportToken() ([]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ExportToken")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_ExportToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExportToken'
type MockClient_ExportToken_Call struct {
	*mock.Call
}

// ExportToken is a helper method to define mock.On call
func (_e *MockClient_Expecter) ExportToken() *MockClient_ExportToken_Call {
	return &MockClient_ExportToken_Call{Call: _e.mock.On("ExportToken")}
}

func (_c *MockClient_ExportToken_Call) Run(run func()) *MockClient_ExportToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockClient_ExportToken_Call) Return(_a0 []byte, _a1 error) *MockClient_ExportToken_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_ExportToken_Call) RunAndReturn(run func() ([]byte, error)) *MockClient_ExportToken_Call {
	_c.Call.Return(run)
	return _c
}

// GetClient provides a mock function with given fields: ctx, realm, client
func (_m *MockClient) GetClient(ctx context.Context, realm string, client string) (*gocloak.Client, error) {
	ret := _m.Called(ctx, realm, client)

	if len(ret) == 0 {
		panic("no return value specified for GetClient")
	}

	var r0 *gocloak.Client
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*gocloak.Client, error)); ok {
		return rf(ctx, realm, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *gocloak.Client); ok {
		r0 = rf(ctx, realm, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.Client)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, realm, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClient'
type MockClient_GetClient_Call struct {
	*mock.Call
}

// GetClient is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - client string
func (_e *MockClient_Expecter) GetClient(ctx interface{}, realm interface{}, client interface{}) *MockClient_GetClient_Call {
	return &MockClient_GetClient_Call{Call: _e.mock.On("GetClient", ctx, realm, client)}
}

func (_c *MockClient_GetClient_Call) Run(run func(ctx context.Context, realm string, client string)) *MockClient_GetClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_GetClient_Call) Return(_a0 *gocloak.Client, _a1 error) *MockClient_GetClient_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetClient_Call) RunAndReturn(run func(context.Context, string, string) (*gocloak.Client, error)) *MockClient_GetClient_Call {
	_c.Call.Return(run)
	return _c
}

// GetClientID provides a mock function with given fields: clientID, realm
func (_m *MockClient) GetClientID(clientID string, realm string) (string, error) {
	ret := _m.Called(clientID, realm)

	if len(ret) == 0 {
		panic("no return value specified for GetClientID")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (string, error)); ok {
		return rf(clientID, realm)
	}
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(clientID, realm)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(clientID, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetClientID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClientID'
type MockClient_GetClientID_Call struct {
	*mock.Call
}

// GetClientID is a helper method to define mock.On call
//   - clientID string
//   - realm string
func (_e *MockClient_Expecter) GetClientID(clientID interface{}, realm interface{}) *MockClient_GetClientID_Call {
	return &MockClient_GetClientID_Call{Call: _e.mock.On("GetClientID", clientID, realm)}
}

func (_c *MockClient_GetClientID_Call) Run(run func(clientID string, realm string)) *MockClient_GetClientID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockClient_GetClientID_Call) Return(_a0 string, _a1 error) *MockClient_GetClientID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetClientID_Call) RunAndReturn(run func(string, string) (string, error)) *MockClient_GetClientID_Call {
	_c.Call.Return(run)
	return _c
}

// GetClientScope provides a mock function with given fields: scopeName, realmName
func (_m *MockClient) GetClientScope(scopeName string, realmName string) (*adapter.ClientScope, error) {
	ret := _m.Called(scopeName, realmName)

	if len(ret) == 0 {
		panic("no return value specified for GetClientScope")
	}

	var r0 *adapter.ClientScope
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*adapter.ClientScope, error)); ok {
		return rf(scopeName, realmName)
	}
	if rf, ok := ret.Get(0).(func(string, string) *adapter.ClientScope); ok {
		r0 = rf(scopeName, realmName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*adapter.ClientScope)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(scopeName, realmName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetClientScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClientScope'
type MockClient_GetClientScope_Call struct {
	*mock.Call
}

// GetClientScope is a helper method to define mock.On call
//   - scopeName string
//   - realmName string
func (_e *MockClient_Expecter) GetClientScope(scopeName interface{}, realmName interface{}) *MockClient_GetClientScope_Call {
	return &MockClient_GetClientScope_Call{Call: _e.mock.On("GetClientScope", scopeName, realmName)}
}

func (_c *MockClient_GetClientScope_Call) Run(run func(scopeName string, realmName string)) *MockClient_GetClientScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockClient_GetClientScope_Call) Return(_a0 *adapter.ClientScope, _a1 error) *MockClient_GetClientScope_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetClientScope_Call) RunAndReturn(run func(string, string) (*adapter.ClientScope, error)) *MockClient_GetClientScope_Call {
	_c.Call.Return(run)
	return _c
}

// GetClientScopeMappers provides a mock function with given fields: ctx, realmName, scopeID
func (_m *MockClient) GetClientScopeMappers(ctx context.Context, realmName string, scopeID string) ([]adapter.ProtocolMapper, error) {
	ret := _m.Called(ctx, realmName, scopeID)

	if len(ret) == 0 {
		panic("no return value specified for GetClientScopeMappers")
	}

	var r0 []adapter.ProtocolMapper
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]adapter.ProtocolMapper, error)); ok {
		return rf(ctx, realmName, scopeID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []adapter.ProtocolMapper); ok {
		r0 = rf(ctx, realmName, scopeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]adapter.ProtocolMapper)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, realmName, scopeID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetClientScopeMappers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClientScopeMappers'
type MockClient_GetClientScopeMappers_Call struct {
	*mock.Call
}

// GetClientScopeMappers is a helper method to define mock.On call
//   - ctx context.Context
//   - realmName string
//   - scopeID string
func (_e *MockClient_Expecter) GetClientScopeMappers(ctx interface{}, realmName interface{}, scopeID interface{}) *MockClient_GetClientScopeMappers_Call {
	return &MockClient_GetClientScopeMappers_Call{Call: _e.mock.On("GetClientScopeMappers", ctx, realmName, scopeID)}
}

func (_c *MockClient_GetClientScopeMappers_Call) Run(run func(ctx context.Context, realmName string, scopeID string)) *MockClient_GetClientScopeMappers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_GetClientScopeMappers_Call) Return(_a0 []adapter.ProtocolMapper, _a1 error) *MockClient_GetClientScopeMappers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetClientScopeMappers_Call) RunAndReturn(run func(context.Context, string, string) ([]adapter.ProtocolMapper, error)) *MockClient_GetClientScopeMappers_Call {
	_c.Call.Return(run)
	return _c
}

// GetClientScopes provides a mock function with given fields: ctx, realm
func (_m *MockClient) GetClientScopes(ctx context.Context, realm string) (map[string]gocloak.ClientScope, error) {
	ret := _m.Called(ctx, realm)

	if len(ret) == 0 {
		panic("no return value specified for GetClientScopes")
	}

	var r0 map[string]gocloak.ClientScope
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (map[string]gocloak.ClientScope, error)); ok {
		return rf(ctx, realm)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) map[string]gocloak.ClientScope); ok {
		r0 = rf(ctx, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]gocloak.ClientScope)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetClientScopes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClientScopes'
type MockClient_GetClientScopes_Call struct {
	*mock.Call
}

// GetClientScopes is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
func (_e *MockClient_Expecter) GetClientScopes(ctx interface{}, realm interface{}) *MockClient_GetClientScopes_Call {
	return &MockClient_GetClientScopes_Call{Call: _e.mock.On("GetClientScopes", ctx, realm)}
}

func (_c *MockClient_GetClientScopes_Call) Run(run func(ctx context.Context, realm string)) *MockClient_GetClientScopes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_GetClientScopes_Call) Return(_a0 map[string]gocloak.ClientScope, _a1 error) *MockClient_GetClientScopes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetClientScopes_Call) RunAndReturn(run func(context.Context, string) (map[string]gocloak.ClientScope, error)) *MockClient_GetClientScopes_Call {
	_c.Call.Return(run)
	return _c
}

// GetClientScopesByNames provides a mock function with given fields: ctx, realmName, scopeNames
func (_m *MockClient) GetClientScopesByNames(ctx context.Context, realmName string, scopeNames []string) ([]adapter.ClientScope, error) {
	ret := _m.Called(ctx, realmName, scopeNames)

	if len(ret) == 0 {
		panic("no return value specified for GetClientScopesByNames")
	}

	var r0 []adapter.ClientScope
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) ([]adapter.ClientScope, error)); ok {
		return rf(ctx, realmName, scopeNames)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) []adapter.ClientScope); ok {
		r0 = rf(ctx, realmName, scopeNames)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]adapter.ClientScope)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = rf(ctx, realmName, scopeNames)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetClientScopesByNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClientScopesByNames'
type MockClient_GetClientScopesByNames_Call struct {
	*mock.Call
}

// GetClientScopesByNames is a helper method to define mock.On call
//   - ctx context.Context
//   - realmName string
//   - scopeNames []string
func (_e *MockClient_Expecter) GetClientScopesByNames(ctx interface{}, realmName interface{}, scopeNames interface{}) *MockClient_GetClientScopesByNames_Call {
	return &MockClient_GetClientScopesByNames_Call{Call: _e.mock.On("GetClientScopesByNames", ctx, realmName, scopeNames)}
}

func (_c *MockClient_GetClientScopesByNames_Call) Run(run func(ctx context.Context, realmName string, scopeNames []string)) *MockClient_GetClientScopesByNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string))
	})
	return _c
}

func (_c *MockClient_GetClientScopesByNames_Call) Return(_a0 []adapter.ClientScope, _a1 error) *MockClient_GetClientScopesByNames_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetClientScopesByNames_Call) RunAndReturn(run func(context.Context, string, []string) ([]adapter.ClientScope, error)) *MockClient_GetClientScopesByNames_Call {
	_c.Call.Return(run)
	return _c
}

// GetClients provides a mock function with given fields: ctx, realm
func (_m *MockClient) GetClients(ctx context.Context, realm string) (map[string]*gocloak.Client, error) {
	ret := _m.Called(ctx, realm)

	if len(ret) == 0 {
		panic("no return value specified for GetClients")
	}

	var r0 map[string]*gocloak.Client
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (map[string]*gocloak.Client, error)); ok {
		return rf(ctx, realm)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) map[string]*gocloak.Client); ok {
		r0 = rf(ctx, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*gocloak.Client)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetClients_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClients'
type MockClient_GetClients_Call struct {
	*mock.Call
}

// GetClients is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
func (_e *MockClient_Expecter) GetClients(ctx interface{}, realm interface{}) *MockClient_GetClients_Call {
	return &MockClient_GetClients_Call{Call: _e.mock.On("GetClients", ctx, realm)}
}

func (_c *MockClient_GetClients_Call) Run(run func(ctx context.Context, realm string)) *MockClient_GetClients_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_GetClients_Call) Return(_a0 map[string]*gocloak.Client, _a1 error) *MockClient_GetClients_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetClients_Call) RunAndReturn(run func(context.Context, string) (map[string]*gocloak.Client, error)) *MockClient_GetClients_Call {
	_c.Call.Return(run)
	return _c
}

// GetComponent provides a mock function with given fields: ctx, realmName, componentName
func (_m *MockClient) GetComponent(ctx context.Context, realmName string, componentName string) (*adapter.Component, error) {
	ret := _m.Called(ctx, realmName, componentName)

	if len(ret) == 0 {
		panic("no return value specified for GetComponent")
	}

	var r0 *adapter.Component
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*adapter.Component, error)); ok {
		return rf(ctx, realmName, componentName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *adapter.Component); ok {
		r0 = rf(ctx, realmName, componentName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*adapter.Component)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, realmName, componentName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetComponent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetComponent'
type MockClient_GetComponent_Call struct {
	*mock.Call
}

// GetComponent is a helper method to define mock.On call
//   - ctx context.Context
//   - realmName string
//   - componentName string
func (_e *MockClient_Expecter) GetComponent(ctx interface{}, realmName interface{}, componentName interface{}) *MockClient_GetComponent_Call {
	return &MockClient_GetComponent_Call{Call: _e.mock.On("GetComponent", ctx, realmName, componentName)}
}

func (_c *MockClient_GetComponent_Call) Run(run func(ctx context.Context, realmName string, componentName string)) *MockClient_GetComponent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_GetComponent_Call) Return(_a0 *adapter.Component, _a1 error) *MockClient_GetComponent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetComponent_Call) RunAndReturn(run func(context.Context, string, string) (*adapter.Component, error)) *MockClient_GetComponent_Call {
	_c.Call.Return(run)
	return _c
}

// GetDefaultClientScopesForRealm provides a mock function with given fields: ctx, realm
func (_m *MockClient) GetDefaultClientScopesForRealm(ctx context.Context, realm string) ([]adapter.ClientScope, error) {
	ret := _m.Called(ctx, realm)

	if len(ret) == 0 {
		panic("no return value specified for GetDefaultClientScopesForRealm")
	}

	var r0 []adapter.ClientScope
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]adapter.ClientScope, error)); ok {
		return rf(ctx, realm)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []adapter.ClientScope); ok {
		r0 = rf(ctx, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]adapter.ClientScope)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetDefaultClientScopesForRealm_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDefaultClientScopesForRealm'
type MockClient_GetDefaultClientScopesForRealm_Call struct {
	*mock.Call
}

// GetDefaultClientScopesForRealm is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
func (_e *MockClient_Expecter) GetDefaultClientScopesForRealm(ctx interface{}, realm interface{}) *MockClient_GetDefaultClientScopesForRealm_Call {
	return &MockClient_GetDefaultClientScopesForRealm_Call{Call: _e.mock.On("GetDefaultClientScopesForRealm", ctx, realm)}
}

func (_c *MockClient_GetDefaultClientScopesForRealm_Call) Run(run func(ctx context.Context, realm string)) *MockClient_GetDefaultClientScopesForRealm_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_GetDefaultClientScopesForRealm_Call) Return(_a0 []adapter.ClientScope, _a1 error) *MockClient_GetDefaultClientScopesForRealm_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetDefaultClientScopesForRealm_Call) RunAndReturn(run func(context.Context, string) ([]adapter.ClientScope, error)) *MockClient_GetDefaultClientScopesForRealm_Call {
	_c.Call.Return(run)
	return _c
}

// GetGroups provides a mock function with given fields: ctx, realm
func (_m *MockClient) GetGroups(ctx context.Context, realm string) (map[string]*gocloak.Group, error) {
	ret := _m.Called(ctx, realm)

	if len(ret) == 0 {
		panic("no return value specified for GetGroups")
	}

	var r0 map[string]*gocloak.Group
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (map[string]*gocloak.Group, error)); ok {
		return rf(ctx, realm)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) map[string]*gocloak.Group); ok {
		r0 = rf(ctx, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*gocloak.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGroups'
type MockClient_GetGroups_Call struct {
	*mock.Call
}

// GetGroups is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
func (_e *MockClient_Expecter) GetGroups(ctx interface{}, realm interface{}) *MockClient_GetGroups_Call {
	return &MockClient_GetGroups_Call{Call: _e.mock.On("GetGroups", ctx, realm)}
}

func (_c *MockClient_GetGroups_Call) Run(run func(ctx context.Context, realm string)) *MockClient_GetGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_GetGroups_Call) Return(_a0 map[string]*gocloak.Group, _a1 error) *MockClient_GetGroups_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetGroups_Call) RunAndReturn(run func(context.Context, string) (map[string]*gocloak.Group, error)) *MockClient_GetGroups_Call {
	_c.Call.Return(run)
	return _c
}

// GetIDPMappers provides a mock function with given fields: ctx, realm, idpAlias
func (_m *MockClient) GetIDPMappers(ctx context.Context, realm string, idpAlias string) ([]adapter.IdentityProviderMapper, error) {
	ret := _m.Called(ctx, realm, idpAlias)

	if len(ret) == 0 {
		panic("no return value specified for GetIDPMappers")
	}

	var r0 []adapter.IdentityProviderMapper
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]adapter.IdentityProviderMapper, error)); ok {
		return rf(ctx, realm, idpAlias)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []adapter.IdentityProviderMapper); ok {
		r0 = rf(ctx, realm, idpAlias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]adapter.IdentityProviderMapper)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, realm, idpAlias)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetIDPMappers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIDPMappers'
type MockClient_GetIDPMappers_Call struct {
	*mock.Call
}

// GetIDPMappers is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idpAlias string
func (_e *MockClient_Expecter) GetIDPMappers(ctx interface{}, realm interface{}, idpAlias interface{}) *MockClient_GetIDPMappers_Call {
	return &MockClient_GetIDPMappers_Call{Call: _e.mock.On("GetIDPMappers", ctx, realm, idpAlias)}
}

func (_c *MockClient_GetIDPMappers_Call) Run(run func(ctx context.Context, realm string, idpAlias string)) *MockClient_GetIDPMappers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_GetIDPMappers_Call) Return(_a0 []adapter.IdentityProviderMapper, _a1 error) *MockClient_GetIDPMappers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetIDPMappers_Call) RunAndReturn(run func(context.Context, string, string) ([]adapter.IdentityProviderMapper, error)) *MockClient_GetIDPMappers_Call {
	_c.Call.Return(run)
	return _c
}

// GetIdentityProvider provides a mock function with given fields: ctx, realm, alias
func (_m *MockClient) GetIdentityProvider(ctx context.Context, realm string, alias string) (*adapter.IdentityProvider, error) {
	ret := _m.Called(ctx, realm, alias)

	if len(ret) == 0 {
		panic("no return value specified for GetIdentityProvider")
	}

	var r0 *adapter.IdentityProvider
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*adapter.IdentityProvider, error)); ok {
		return rf(ctx, realm, alias)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *adapter.IdentityProvider); ok {
		r0 = rf(ctx, realm, alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*adapter.IdentityProvider)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, realm, alias)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetIdentityProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIdentityProvider'
type MockClient_GetIdentityProvider_Call struct {
	*mock.Call
}

// GetIdentityProvider is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - alias string
func (_e *MockClient_Expecter) GetIdentityProvider(ctx interface{}, realm interface{}, alias interface{}) *MockClient_GetIdentityProvider_Call {
	return &MockClient_GetIdentityProvider_Call{Call: _e.mock.On("GetIdentityProvider", ctx, realm, alias)}
}

func (_c *MockClient_GetIdentityProvider_Call) Run(run func(ctx context.Context, realm string, alias string)) *MockClient_GetIdentityProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_GetIdentityProvider_Call) Return(_a0 *adapter.IdentityProvider, _a1 error) *MockClient_GetIdentityProvider_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetIdentityProvider_Call) RunAndReturn(run func(context.Context, string, string) (*adapter.IdentityProvider, error)) *MockClient_GetIdentityProvider_Call {
	_c.Call.Return(run)
	return _c
}

// GetOpenIdConfig provides a mock function with given fields: realm
func (_m *MockClient) GetOpenIdConfig(realm *dto.Realm) (string, error) {
	ret := _m.Called(realm)

	if len(ret) == 0 {
		panic("no return value specified for GetOpenIdConfig")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(*dto.Realm) (string, error)); ok {
		return rf(realm)
	}
	if rf, ok := ret.Get(0).(func(*dto.Realm) string); ok {
		r0 = rf(realm)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(*dto.Realm) error); ok {
		r1 = rf(realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetOpenIdConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOpenIdConfig'
type MockClient_GetOpenIdConfig_Call struct {
	*mock.Call
}

// GetOpenIdConfig is a helper method to define mock.On call
//   - realm *dto.Realm
func (_e *MockClient_Expecter) GetOpenIdConfig(realm interface{}) *MockClient_GetOpenIdConfig_Call {
	return &MockClient_GetOpenIdConfig_Call{Call: _e.mock.On("GetOpenIdConfig", realm)}
}

func (_c *MockClient_GetOpenIdConfig_Call) Run(run func(realm *dto.Realm)) *MockClient_GetOpenIdConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*dto.Realm))
	})
	return _c
}

func (_c *MockClient_GetOpenIdConfig_Call) Return(_a0 string, _a1 error) *MockClient_GetOpenIdConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetOpenIdConfig_Call) RunAndReturn(run func(*dto.Realm) (string, error)) *MockClient_GetOpenIdConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetPermissions provides a mock function with given fields: ctx, realm, idOfClient
func (_m *MockClient) GetPermissions(ctx context.Context, realm string, idOfClient string) (map[string]gocloak.PermissionRepresentation, error) {
	ret := _m.Called(ctx, realm, idOfClient)

	if len(ret) == 0 {
		panic("no return value specified for GetPermissions")
	}

	var r0 map[string]gocloak.PermissionRepresentation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (map[string]gocloak.PermissionRepresentation, error)); ok {
		return rf(ctx, realm, idOfClient)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) map[string]gocloak.PermissionRepresentation); ok {
		r0 = rf(ctx, realm, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]gocloak.PermissionRepresentation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, realm, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetPermissions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPermissions'
type MockClient_GetPermissions_Call struct {
	*mock.Call
}

// GetPermissions is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idOfClient string
func (_e *MockClient_Expecter) GetPermissions(ctx interface{}, realm interface{}, idOfClient interface{}) *MockClient_GetPermissions_Call {
	return &MockClient_GetPermissions_Call{Call: _e.mock.On("GetPermissions", ctx, realm, idOfClient)}
}

func (_c *MockClient_GetPermissions_Call) Run(run func(ctx context.Context, realm string, idOfClient string)) *MockClient_GetPermissions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_GetPermissions_Call) Return(_a0 map[string]gocloak.PermissionRepresentation, _a1 error) *MockClient_GetPermissions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetPermissions_Call) RunAndReturn(run func(context.Context, string, string) (map[string]gocloak.PermissionRepresentation, error)) *MockClient_GetPermissions_Call {
	_c.Call.Return(run)
	return _c
}

// GetPolicies provides a mock function with given fields: ctx, realm, idOfClient
func (_m *MockClient) GetPolicies(ctx context.Context, realm string, idOfClient string) (map[string]*gocloak.PolicyRepresentation, error) {
	ret := _m.Called(ctx, realm, idOfClient)

	if len(ret) == 0 {
		panic("no return value specified for GetPolicies")
	}

	var r0 map[string]*gocloak.PolicyRepresentation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (map[string]*gocloak.PolicyRepresentation, error)); ok {
		return rf(ctx, realm, idOfClient)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) map[string]*gocloak.PolicyRepresentation); ok {
		r0 = rf(ctx, realm, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*gocloak.PolicyRepresentation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, realm, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPolicies'
type MockClient_GetPolicies_Call struct {
	*mock.Call
}

// GetPolicies is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idOfClient string
func (_e *MockClient_Expecter) GetPolicies(ctx interface{}, realm interface{}, idOfClient interface{}) *MockClient_GetPolicies_Call {
	return &MockClient_GetPolicies_Call{Call: _e.mock.On("GetPolicies", ctx, realm, idOfClient)}
}

func (_c *MockClient_GetPolicies_Call) Run(run func(ctx context.Context, realm string, idOfClient string)) *MockClient_GetPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_GetPolicies_Call) Return(_a0 map[string]*gocloak.PolicyRepresentation, _a1 error) *MockClient_GetPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetPolicies_Call) RunAndReturn(run func(context.Context, string, string) (map[string]*gocloak.PolicyRepresentation, error)) *MockClient_GetPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// GetRealm provides a mock function with given fields: ctx, realm
func (_m *MockClient) GetRealm(ctx context.Context, realm string) (*gocloak.RealmRepresentation, error) {
	ret := _m.Called(ctx, realm)

	if len(ret) == 0 {
		panic("no return value specified for GetRealm")
	}

	var r0 *gocloak.RealmRepresentation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*gocloak.RealmRepresentation, error)); ok {
		return rf(ctx, realm)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *gocloak.RealmRepresentation); ok {
		r0 = rf(ctx, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.RealmRepresentation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetRealm_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRealm'
type MockClient_GetRealm_Call struct {
	*mock.Call
}

// GetRealm is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
func (_e *MockClient_Expecter) GetRealm(ctx interface{}, realm interface{}) *MockClient_GetRealm_Call {
	return &MockClient_GetRealm_Call{Call: _e.mock.On("GetRealm", ctx, realm)}
}

func (_c *MockClient_GetRealm_Call) Run(run func(ctx context.Context, realm string)) *MockClient_GetRealm_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_GetRealm_Call) Return(_a0 *gocloak.RealmRepresentation, _a1 error) *MockClient_GetRealm_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetRealm_Call) RunAndReturn(run func(context.Context, string) (*gocloak.RealmRepresentation, error)) *MockClient_GetRealm_Call {
	_c.Call.Return(run)
	return _c
}

// GetRealmRoles provides a mock function with given fields: ctx, realm
func (_m *MockClient) GetRealmRoles(ctx context.Context, realm string) (map[string]gocloak.Role, error) {
	ret := _m.Called(ctx, realm)

	if len(ret) == 0 {
		panic("no return value specified for GetRealmRoles")
	}

	var r0 map[string]gocloak.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (map[string]gocloak.Role, error)); ok {
		return rf(ctx, realm)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) map[string]gocloak.Role); ok {
		r0 = rf(ctx, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]gocloak.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetRealmRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRealmRoles'
type MockClient_GetRealmRoles_Call struct {
	*mock.Call
}

// GetRealmRoles is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
func (_e *MockClient_Expecter) GetRealmRoles(ctx interface{}, realm interface{}) *MockClient_GetRealmRoles_Call {
	return &MockClient_GetRealmRoles_Call{Call: _e.mock.On("GetRealmRoles", ctx, realm)}
}

func (_c *MockClient_GetRealmRoles_Call) Run(run func(ctx context.Context, realm string)) *MockClient_GetRealmRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_GetRealmRoles_Call) Return(_a0 map[string]gocloak.Role, _a1 error) *MockClient_GetRealmRoles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetRealmRoles_Call) RunAndReturn(run func(context.Context, string) (map[string]gocloak.Role, error)) *MockClient_GetRealmRoles_Call {
	_c.Call.Return(run)
	return _c
}

// GetResources provides a mock function with given fields: ctx, realm, idOfClient
func (_m *MockClient) GetResources(ctx context.Context, realm string, idOfClient string) (map[string]gocloak.ResourceRepresentation, error) {
	ret := _m.Called(ctx, realm, idOfClient)

	if len(ret) == 0 {
		panic("no return value specified for GetResources")
	}

	var r0 map[string]gocloak.ResourceRepresentation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (map[string]gocloak.ResourceRepresentation, error)); ok {
		return rf(ctx, realm, idOfClient)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) map[string]gocloak.ResourceRepresentation); ok {
		r0 = rf(ctx, realm, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]gocloak.ResourceRepresentation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, realm, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetResources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetResources'
type MockClient_GetResources_Call struct {
	*mock.Call
}

// GetResources is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idOfClient string
func (_e *MockClient_Expecter) GetResources(ctx interface{}, realm interface{}, idOfClient interface{}) *MockClient_GetResources_Call {
	return &MockClient_GetResources_Call{Call: _e.mock.On("GetResources", ctx, realm, idOfClient)}
}

func (_c *MockClient_GetResources_Call) Run(run func(ctx context.Context, realm string, idOfClient string)) *MockClient_GetResources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_GetResources_Call) Return(_a0 map[string]gocloak.ResourceRepresentation, _a1 error) *MockClient_GetResources_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetResources_Call) RunAndReturn(run func(context.Context, string, string) (map[string]gocloak.ResourceRepresentation, error)) *MockClient_GetResources_Call {
	_c.Call.Return(run)
	return _c
}

// GetScopes provides a mock function with given fields: ctx, realm, idOfClient
func (_m *MockClient) GetScopes(ctx context.Context, realm string, idOfClient string) (map[string]gocloak.ScopeRepresentation, error) {
	ret := _m.Called(ctx, realm, idOfClient)

	if len(ret) == 0 {
		panic("no return value specified for GetScopes")
	}

	var r0 map[string]gocloak.ScopeRepresentation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (map[string]gocloak.ScopeRepresentation, error)); ok {
		return rf(ctx, realm, idOfClient)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) map[string]gocloak.ScopeRepresentation); ok {
		r0 = rf(ctx, realm, idOfClient)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]gocloak.ScopeRepresentation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, realm, idOfClient)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetScopes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetScopes'
type MockClient_GetScopes_Call struct {
	*mock.Call
}

// GetScopes is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idOfClient string
func (_e *MockClient_Expecter) GetScopes(ctx interface{}, realm interface{}, idOfClient interface{}) *MockClient_GetScopes_Call {
	return &MockClient_GetScopes_Call{Call: _e.mock.On("GetScopes", ctx, realm, idOfClient)}
}

func (_c *MockClient_GetScopes_Call) Run(run func(ctx context.Context, realm string, idOfClient string)) *MockClient_GetScopes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_GetScopes_Call) Return(_a0 map[string]gocloak.ScopeRepresentation, _a1 error) *MockClient_GetScopes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetScopes_Call) RunAndReturn(run func(context.Context, string, string) (map[string]gocloak.ScopeRepresentation, error)) *MockClient_GetScopes_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsersByNames provides a mock function with given fields: ctx, realm, names
func (_m *MockClient) GetUsersByNames(ctx context.Context, realm string, names []string) (map[string]gocloak.User, error) {
	ret := _m.Called(ctx, realm, names)

	if len(ret) == 0 {
		panic("no return value specified for GetUsersByNames")
	}

	var r0 map[string]gocloak.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) (map[string]gocloak.User, error)); ok {
		return rf(ctx, realm, names)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) map[string]gocloak.User); ok {
		r0 = rf(ctx, realm, names)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]gocloak.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = rf(ctx, realm, names)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetUsersByNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsersByNames'
type MockClient_GetUsersByNames_Call struct {
	*mock.Call
}

// GetUsersByNames is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - names []string
func (_e *MockClient_Expecter) GetUsersByNames(ctx interface{}, realm interface{}, names interface{}) *MockClient_GetUsersByNames_Call {
	return &MockClient_GetUsersByNames_Call{Call: _e.mock.On("GetUsersByNames", ctx, realm, names)}
}

func (_c *MockClient_GetUsersByNames_Call) Run(run func(ctx context.Context, realm string, names []string)) *MockClient_GetUsersByNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string))
	})
	return _c
}

func (_c *MockClient_GetUsersByNames_Call) Return(_a0 map[string]gocloak.User, _a1 error) *MockClient_GetUsersByNames_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetUsersByNames_Call) RunAndReturn(run func(context.Context, string, []string) (map[string]gocloak.User, error)) *MockClient_GetUsersByNames_Call {
	_c.Call.Return(run)
	return _c
}

// HasUserClientRole provides a mock function with given fields: realmName, clientId, user, role
func (_m *MockClient) HasUserClientRole(realmName string, clientId string, user *dto.User, role string) (bool, error) {
	ret := _m.Called(realmName, clientId, user, role)

	if len(ret) == 0 {
		panic("no return value specified for HasUserClientRole")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, *dto.User, string) (bool, error)); ok {
		return rf(realmName, clientId, user, role)
	}
	if rf, ok := ret.Get(0).(func(string, string, *dto.User, string) bool); ok {
		r0 = rf(realmName, clientId, user, role)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, *dto.User, string) error); ok {
		r1 = rf(realmName, clientId, user, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_HasUserClientRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasUserClientRole'
type MockClient_HasUserClientRole_Call struct {
	*mock.Call
}

// HasUserClientRole is a helper method to define mock.On call
//   - realmName string
//   - clientId string
//   - user *dto.User
//   - role string
func (_e *MockClient_Expecter) HasUserClientRole(realmName interface{}, clientId interface{}, user interface{}, role interface{}) *MockClient_HasUserClientRole_Call {
	return &MockClient_HasUserClientRole_Call{Call: _e.mock.On("HasUserClientRole", realmName, clientId, user, role)}
}

func (_c *MockClient_HasUserClientRole_Call) Run(run func(realmName string, clientId string, user *dto.User, role string)) *MockClient_HasUserClientRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(*dto.User), args[3].(string))
	})
	return _c
}

func (_c *MockClient_HasUserClientRole_Call) Return(_a0 bool, _a1 error) *MockClient_HasUserClientRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_HasUserClientRole_Call) RunAndReturn(run func(string, string, *dto.User, string) (bool, error)) *MockClient_HasUserClientRole_Call {
	_c.Call.Return(run)
	return _c
}

// HasUserRealmRole provides a mock function with given fields: realmName, user, role
func (_m *MockClient) HasUserRealmRole(realmName string, user *dto.User, role string) (bool, error) {
	ret := _m.Called(realmName, user, role)

	if len(ret) == 0 {
		panic("no return value specified for HasUserRealmRole")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *dto.User, string) (bool, error)); ok {
		return rf(realmName, user, role)
	}
	if rf, ok := ret.Get(0).(func(string, *dto.User, string) bool); ok {
		r0 = rf(realmName, user, role)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, *dto.User, string) error); ok {
		r1 = rf(realmName, user, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_HasUserRealmRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasUserRealmRole'
type MockClient_HasUserRealmRole_Call struct {
	*mock.Call
}

// HasUserRealmRole is a helper method to define mock.On call
//   - realmName string
//   - user *dto.User
//   - role string
func (_e *MockClient_Expecter) HasUserRealmRole(realmName interface{}, user interface{}, role interface{}) *MockClient_HasUserRealmRole_Call {
	return &MockClient_HasUserRealmRole_Call{Call: _e.mock.On("HasUserRealmRole", realmName, user, role)}
}

func (_c *MockClient_HasUserRealmRole_Call) Run(run func(realmName string, user *dto.User, role string)) *MockClient_HasUserRealmRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*dto.User), args[2].(string))
	})
	return _c
}

func (_c *MockClient_HasUserRealmRole_Call) Return(_a0 bool, _a1 error) *MockClient_HasUserRealmRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_HasUserRealmRole_Call) RunAndReturn(run func(string, *dto.User, string) (bool, error)) *MockClient_HasUserRealmRole_Call {
	_c.Call.Return(run)
	return _c
}

// IdentityProviderExists provides a mock function with given fields: ctx, realm, alias
func (_m *MockClient) IdentityProviderExists(ctx context.Context, realm string, alias string) (bool, error) {
	ret := _m.Called(ctx, realm, alias)

	if len(ret) == 0 {
		panic("no return value specified for IdentityProviderExists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return rf(ctx, realm, alias)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, realm, alias)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, realm, alias)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_IdentityProviderExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IdentityProviderExists'
type MockClient_IdentityProviderExists_Call struct {
	*mock.Call
}

// IdentityProviderExists is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - alias string
func (_e *MockClient_Expecter) IdentityProviderExists(ctx interface{}, realm interface{}, alias interface{}) *MockClient_IdentityProviderExists_Call {
	return &MockClient_IdentityProviderExists_Call{Call: _e.mock.On("IdentityProviderExists", ctx, realm, alias)}
}

func (_c *MockClient_IdentityProviderExists_Call) Run(run func(ctx context.Context, realm string, alias string)) *MockClient_IdentityProviderExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_IdentityProviderExists_Call) Return(_a0 bool, _a1 error) *MockClient_IdentityProviderExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_IdentityProviderExists_Call) RunAndReturn(run func(context.Context, string, string) (bool, error)) *MockClient_IdentityProviderExists_Call {
	_c.Call.Return(run)
	return _c
}

// PutClientScopeMapper provides a mock function with given fields: realmName, scopeID, protocolMapper
func (_m *MockClient) PutClientScopeMapper(realmName string, scopeID string, protocolMapper *adapter.ProtocolMapper) error {
	ret := _m.Called(realmName, scopeID, protocolMapper)

	if len(ret) == 0 {
		panic("no return value specified for PutClientScopeMapper")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, *adapter.ProtocolMapper) error); ok {
		r0 = rf(realmName, scopeID, protocolMapper)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_PutClientScopeMapper_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutClientScopeMapper'
type MockClient_PutClientScopeMapper_Call struct {
	*mock.Call
}

// PutClientScopeMapper is a helper method to define mock.On call
//   - realmName string
//   - scopeID string
//   - protocolMapper *adapter.ProtocolMapper
func (_e *MockClient_Expecter) PutClientScopeMapper(realmName interface{}, scopeID interface{}, protocolMapper interface{}) *MockClient_PutClientScopeMapper_Call {
	return &MockClient_PutClientScopeMapper_Call{Call: _e.mock.On("PutClientScopeMapper", realmName, scopeID, protocolMapper)}
}

func (_c *MockClient_PutClientScopeMapper_Call) Run(run func(realmName string, scopeID string, protocolMapper *adapter.ProtocolMapper)) *MockClient_PutClientScopeMapper_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(*adapter.ProtocolMapper))
	})
	return _c
}

func (_c *MockClient_PutClientScopeMapper_Call) Return(_a0 error) *MockClient_PutClientScopeMapper_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_PutClientScopeMapper_Call) RunAndReturn(run func(string, string, *adapter.ProtocolMapper) error) *MockClient_PutClientScopeMapper_Call {
	_c.Call.Return(run)
	return _c
}

// SetRealmBrowserFlow provides a mock function with given fields: realmName, flowAlias
func (_m *MockClient) SetRealmBrowserFlow(realmName string, flowAlias string) error {
	ret := _m.Called(realmName, flowAlias)

	if len(ret) == 0 {
		panic("no return value specified for SetRealmBrowserFlow")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(realmName, flowAlias)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SetRealmBrowserFlow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRealmBrowserFlow'
type MockClient_SetRealmBrowserFlow_Call struct {
	*mock.Call
}

// SetRealmBrowserFlow is a helper method to define mock.On call
//   - realmName string
//   - flowAlias string
func (_e *MockClient_Expecter) SetRealmBrowserFlow(realmName interface{}, flowAlias interface{}) *MockClient_SetRealmBrowserFlow_Call {
	return &MockClient_SetRealmBrowserFlow_Call{Call: _e.mock.On("SetRealmBrowserFlow", realmName, flowAlias)}
}

func (_c *MockClient_SetRealmBrowserFlow_Call) Run(run func(realmName string, flowAlias string)) *MockClient_SetRealmBrowserFlow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockClient_SetRealmBrowserFlow_Call) Return(_a0 error) *MockClient_SetRealmBrowserFlow_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SetRealmBrowserFlow_Call) RunAndReturn(run func(string, string) error) *MockClient_SetRealmBrowserFlow_Call {
	_c.Call.Return(run)
	return _c
}

// SetRealmEventConfig provides a mock function with given fields: realmName, eventConfig
func (_m *MockClient) SetRealmEventConfig(realmName string, eventConfig *adapter.RealmEventConfig) error {
	ret := _m.Called(realmName, eventConfig)

	if len(ret) == 0 {
		panic("no return value specified for SetRealmEventConfig")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *adapter.RealmEventConfig) error); ok {
		r0 = rf(realmName, eventConfig)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SetRealmEventConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRealmEventConfig'
type MockClient_SetRealmEventConfig_Call struct {
	*mock.Call
}

// SetRealmEventConfig is a helper method to define mock.On call
//   - realmName string
//   - eventConfig *adapter.RealmEventConfig
func (_e *MockClient_Expecter) SetRealmEventConfig(realmName interface{}, eventConfig interface{}) *MockClient_SetRealmEventConfig_Call {
	return &MockClient_SetRealmEventConfig_Call{Call: _e.mock.On("SetRealmEventConfig", realmName, eventConfig)}
}

func (_c *MockClient_SetRealmEventConfig_Call) Run(run func(realmName string, eventConfig *adapter.RealmEventConfig)) *MockClient_SetRealmEventConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*adapter.RealmEventConfig))
	})
	return _c
}

func (_c *MockClient_SetRealmEventConfig_Call) Return(_a0 error) *MockClient_SetRealmEventConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SetRealmEventConfig_Call) RunAndReturn(run func(string, *adapter.RealmEventConfig) error) *MockClient_SetRealmEventConfig_Call {
	_c.Call.Return(run)
	return _c
}

// SetServiceAccountAttributes provides a mock function with given fields: realm, clientID, attributes, addOnly
func (_m *MockClient) SetServiceAccountAttributes(realm string, clientID string, attributes map[string]string, addOnly bool) error {
	ret := _m.Called(realm, clientID, attributes, addOnly)

	if len(ret) == 0 {
		panic("no return value specified for SetServiceAccountAttributes")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, map[string]string, bool) error); ok {
		r0 = rf(realm, clientID, attributes, addOnly)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SetServiceAccountAttributes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetServiceAccountAttributes'
type MockClient_SetServiceAccountAttributes_Call struct {
	*mock.Call
}

// SetServiceAccountAttributes is a helper method to define mock.On call
//   - realm string
//   - clientID string
//   - attributes map[string]string
//   - addOnly bool
func (_e *MockClient_Expecter) SetServiceAccountAttributes(realm interface{}, clientID interface{}, attributes interface{}, addOnly interface{}) *MockClient_SetServiceAccountAttributes_Call {
	return &MockClient_SetServiceAccountAttributes_Call{Call: _e.mock.On("SetServiceAccountAttributes", realm, clientID, attributes, addOnly)}
}

func (_c *MockClient_SetServiceAccountAttributes_Call) Run(run func(realm string, clientID string, attributes map[string]string, addOnly bool)) *MockClient_SetServiceAccountAttributes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(map[string]string), args[3].(bool))
	})
	return _c
}

func (_c *MockClient_SetServiceAccountAttributes_Call) Return(_a0 error) *MockClient_SetServiceAccountAttributes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SetServiceAccountAttributes_Call) RunAndReturn(run func(string, string, map[string]string, bool) error) *MockClient_SetServiceAccountAttributes_Call {
	_c.Call.Return(run)
	return _c
}

// SyncAuthFlow provides a mock function with given fields: realmName, flow
func (_m *MockClient) SyncAuthFlow(realmName string, flow *adapter.KeycloakAuthFlow) error {
	ret := _m.Called(realmName, flow)

	if len(ret) == 0 {
		panic("no return value specified for SyncAuthFlow")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *adapter.KeycloakAuthFlow) error); ok {
		r0 = rf(realmName, flow)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SyncAuthFlow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncAuthFlow'
type MockClient_SyncAuthFlow_Call struct {
	*mock.Call
}

// SyncAuthFlow is a helper method to define mock.On call
//   - realmName string
//   - flow *adapter.KeycloakAuthFlow
func (_e *MockClient_Expecter) SyncAuthFlow(realmName interface{}, flow interface{}) *MockClient_SyncAuthFlow_Call {
	return &MockClient_SyncAuthFlow_Call{Call: _e.mock.On("SyncAuthFlow", realmName, flow)}
}

func (_c *MockClient_SyncAuthFlow_Call) Run(run func(realmName string, flow *adapter.KeycloakAuthFlow)) *MockClient_SyncAuthFlow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*adapter.KeycloakAuthFlow))
	})
	return _c
}

func (_c *MockClient_SyncAuthFlow_Call) Return(_a0 error) *MockClient_SyncAuthFlow_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SyncAuthFlow_Call) RunAndReturn(run func(string, *adapter.KeycloakAuthFlow) error) *MockClient_SyncAuthFlow_Call {
	_c.Call.Return(run)
	return _c
}

// SyncClientProtocolMapper provides a mock function with given fields: client, crMappers, addOnly
func (_m *MockClient) SyncClientProtocolMapper(client *dto.Client, crMappers []gocloak.ProtocolMapperRepresentation, addOnly bool) error {
	ret := _m.Called(client, crMappers, addOnly)

	if len(ret) == 0 {
		panic("no return value specified for SyncClientProtocolMapper")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*dto.Client, []gocloak.ProtocolMapperRepresentation, bool) error); ok {
		r0 = rf(client, crMappers, addOnly)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SyncClientProtocolMapper_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncClientProtocolMapper'
type MockClient_SyncClientProtocolMapper_Call struct {
	*mock.Call
}

// SyncClientProtocolMapper is a helper method to define mock.On call
//   - client *dto.Client
//   - crMappers []gocloak.ProtocolMapperRepresentation
//   - addOnly bool
func (_e *MockClient_Expecter) SyncClientProtocolMapper(client interface{}, crMappers interface{}, addOnly interface{}) *MockClient_SyncClientProtocolMapper_Call {
	return &MockClient_SyncClientProtocolMapper_Call{Call: _e.mock.On("SyncClientProtocolMapper", client, crMappers, addOnly)}
}

func (_c *MockClient_SyncClientProtocolMapper_Call) Run(run func(client *dto.Client, crMappers []gocloak.ProtocolMapperRepresentation, addOnly bool)) *MockClient_SyncClientProtocolMapper_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*dto.Client), args[1].([]gocloak.ProtocolMapperRepresentation), args[2].(bool))
	})
	return _c
}

func (_c *MockClient_SyncClientProtocolMapper_Call) Return(_a0 error) *MockClient_SyncClientProtocolMapper_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SyncClientProtocolMapper_Call) RunAndReturn(run func(*dto.Client, []gocloak.ProtocolMapperRepresentation, bool) error) *MockClient_SyncClientProtocolMapper_Call {
	_c.Call.Return(run)
	return _c
}

// SyncRealmGroup provides a mock function with given fields: realm, spec
func (_m *MockClient) SyncRealmGroup(realm string, spec *v1.KeycloakRealmGroupSpec) (string, error) {
	ret := _m.Called(realm, spec)

	if len(ret) == 0 {
		panic("no return value specified for SyncRealmGroup")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *v1.KeycloakRealmGroupSpec) (string, error)); ok {
		return rf(realm, spec)
	}
	if rf, ok := ret.Get(0).(func(string, *v1.KeycloakRealmGroupSpec) string); ok {
		r0 = rf(realm, spec)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, *v1.KeycloakRealmGroupSpec) error); ok {
		r1 = rf(realm, spec)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_SyncRealmGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncRealmGroup'
type MockClient_SyncRealmGroup_Call struct {
	*mock.Call
}

// SyncRealmGroup is a helper method to define mock.On call
//   - realm string
//   - spec *v1.KeycloakRealmGroupSpec
func (_e *MockClient_Expecter) SyncRealmGroup(realm interface{}, spec interface{}) *MockClient_SyncRealmGroup_Call {
	return &MockClient_SyncRealmGroup_Call{Call: _e.mock.On("SyncRealmGroup", realm, spec)}
}

func (_c *MockClient_SyncRealmGroup_Call) Run(run func(realm string, spec *v1.KeycloakRealmGroupSpec)) *MockClient_SyncRealmGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*v1.KeycloakRealmGroupSpec))
	})
	return _c
}

func (_c *MockClient_SyncRealmGroup_Call) Return(_a0 string, _a1 error) *MockClient_SyncRealmGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_SyncRealmGroup_Call) RunAndReturn(run func(string, *v1.KeycloakRealmGroupSpec) (string, error)) *MockClient_SyncRealmGroup_Call {
	_c.Call.Return(run)
	return _c
}

// SyncRealmIdentityProviderMappers provides a mock function with given fields: realmName, mappers
func (_m *MockClient) SyncRealmIdentityProviderMappers(realmName string, mappers []dto.IdentityProviderMapper) error {
	ret := _m.Called(realmName, mappers)

	if len(ret) == 0 {
		panic("no return value specified for SyncRealmIdentityProviderMappers")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, []dto.IdentityProviderMapper) error); ok {
		r0 = rf(realmName, mappers)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SyncRealmIdentityProviderMappers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncRealmIdentityProviderMappers'
type MockClient_SyncRealmIdentityProviderMappers_Call struct {
	*mock.Call
}

// SyncRealmIdentityProviderMappers is a helper method to define mock.On call
//   - realmName string
//   - mappers []dto.IdentityProviderMapper
func (_e *MockClient_Expecter) SyncRealmIdentityProviderMappers(realmName interface{}, mappers interface{}) *MockClient_SyncRealmIdentityProviderMappers_Call {
	return &MockClient_SyncRealmIdentityProviderMappers_Call{Call: _e.mock.On("SyncRealmIdentityProviderMappers", realmName, mappers)}
}

func (_c *MockClient_SyncRealmIdentityProviderMappers_Call) Run(run func(realmName string, mappers []dto.IdentityProviderMapper)) *MockClient_SyncRealmIdentityProviderMappers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]dto.IdentityProviderMapper))
	})
	return _c
}

func (_c *MockClient_SyncRealmIdentityProviderMappers_Call) Return(_a0 error) *MockClient_SyncRealmIdentityProviderMappers_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SyncRealmIdentityProviderMappers_Call) RunAndReturn(run func(string, []dto.IdentityProviderMapper) error) *MockClient_SyncRealmIdentityProviderMappers_Call {
	_c.Call.Return(run)
	return _c
}

// SyncRealmRole provides a mock function with given fields: ctx, realmName, role
func (_m *MockClient) SyncRealmRole(ctx context.Context, realmName string, role *dto.PrimaryRealmRole) error {
	ret := _m.Called(ctx, realmName, role)

	if len(ret) == 0 {
		panic("no return value specified for SyncRealmRole")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *dto.PrimaryRealmRole) error); ok {
		r0 = rf(ctx, realmName, role)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SyncRealmRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncRealmRole'
type MockClient_SyncRealmRole_Call struct {
	*mock.Call
}

// SyncRealmRole is a helper method to define mock.On call
//   - ctx context.Context
//   - realmName string
//   - role *dto.PrimaryRealmRole
func (_e *MockClient_Expecter) SyncRealmRole(ctx interface{}, realmName interface{}, role interface{}) *MockClient_SyncRealmRole_Call {
	return &MockClient_SyncRealmRole_Call{Call: _e.mock.On("SyncRealmRole", ctx, realmName, role)}
}

func (_c *MockClient_SyncRealmRole_Call) Run(run func(ctx context.Context, realmName string, role *dto.PrimaryRealmRole)) *MockClient_SyncRealmRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*dto.PrimaryRealmRole))
	})
	return _c
}

func (_c *MockClient_SyncRealmRole_Call) Return(_a0 error) *MockClient_SyncRealmRole_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SyncRealmRole_Call) RunAndReturn(run func(context.Context, string, *dto.PrimaryRealmRole) error) *MockClient_SyncRealmRole_Call {
	_c.Call.Return(run)
	return _c
}

// SyncRealmUser provides a mock function with given fields: ctx, realmName, user, addOnly
func (_m *MockClient) SyncRealmUser(ctx context.Context, realmName string, user *adapter.KeycloakUser, addOnly bool) error {
	ret := _m.Called(ctx, realmName, user, addOnly)

	if len(ret) == 0 {
		panic("no return value specified for SyncRealmUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *adapter.KeycloakUser, bool) error); ok {
		r0 = rf(ctx, realmName, user, addOnly)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SyncRealmUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncRealmUser'
type MockClient_SyncRealmUser_Call struct {
	*mock.Call
}

// SyncRealmUser is a helper method to define mock.On call
//   - ctx context.Context
//   - realmName string
//   - user *adapter.KeycloakUser
//   - addOnly bool
func (_e *MockClient_Expecter) SyncRealmUser(ctx interface{}, realmName interface{}, user interface{}, addOnly interface{}) *MockClient_SyncRealmUser_Call {
	return &MockClient_SyncRealmUser_Call{Call: _e.mock.On("SyncRealmUser", ctx, realmName, user, addOnly)}
}

func (_c *MockClient_SyncRealmUser_Call) Run(run func(ctx context.Context, realmName string, user *adapter.KeycloakUser, addOnly bool)) *MockClient_SyncRealmUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*adapter.KeycloakUser), args[3].(bool))
	})
	return _c
}

func (_c *MockClient_SyncRealmUser_Call) Return(_a0 error) *MockClient_SyncRealmUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SyncRealmUser_Call) RunAndReturn(run func(context.Context, string, *adapter.KeycloakUser, bool) error) *MockClient_SyncRealmUser_Call {
	_c.Call.Return(run)
	return _c
}

// SyncServiceAccountRoles provides a mock function with given fields: realm, clientID, realmRoles, clientRoles, addOnly
func (_m *MockClient) SyncServiceAccountRoles(realm string, clientID string, realmRoles []string, clientRoles map[string][]string, addOnly bool) error {
	ret := _m.Called(realm, clientID, realmRoles, clientRoles, addOnly)

	if len(ret) == 0 {
		panic("no return value specified for SyncServiceAccountRoles")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, []string, map[string][]string, bool) error); ok {
		r0 = rf(realm, clientID, realmRoles, clientRoles, addOnly)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_SyncServiceAccountRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncServiceAccountRoles'
type MockClient_SyncServiceAccountRoles_Call struct {
	*mock.Call
}

// SyncServiceAccountRoles is a helper method to define mock.On call
//   - realm string
//   - clientID string
//   - realmRoles []string
//   - clientRoles map[string][]string
//   - addOnly bool
func (_e *MockClient_Expecter) SyncServiceAccountRoles(realm interface{}, clientID interface{}, realmRoles interface{}, clientRoles interface{}, addOnly interface{}) *MockClient_SyncServiceAccountRoles_Call {
	return &MockClient_SyncServiceAccountRoles_Call{Call: _e.mock.On("SyncServiceAccountRoles", realm, clientID, realmRoles, clientRoles, addOnly)}
}

func (_c *MockClient_SyncServiceAccountRoles_Call) Run(run func(realm string, clientID string, realmRoles []string, clientRoles map[string][]string, addOnly bool)) *MockClient_SyncServiceAccountRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].([]string), args[3].(map[string][]string), args[4].(bool))
	})
	return _c
}

func (_c *MockClient_SyncServiceAccountRoles_Call) Return(_a0 error) *MockClient_SyncServiceAccountRoles_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_SyncServiceAccountRoles_Call) RunAndReturn(run func(string, string, []string, map[string][]string, bool) error) *MockClient_SyncServiceAccountRoles_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateClient provides a mock function with given fields: ctx, client
func (_m *MockClient) UpdateClient(ctx context.Context, client *dto.Client) error {
	ret := _m.Called(ctx, client)

	if len(ret) == 0 {
		panic("no return value specified for UpdateClient")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *dto.Client) error); ok {
		r0 = rf(ctx, client)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_UpdateClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateClient'
type MockClient_UpdateClient_Call struct {
	*mock.Call
}

// UpdateClient is a helper method to define mock.On call
//   - ctx context.Context
//   - client *dto.Client
func (_e *MockClient_Expecter) UpdateClient(ctx interface{}, client interface{}) *MockClient_UpdateClient_Call {
	return &MockClient_UpdateClient_Call{Call: _e.mock.On("UpdateClient", ctx, client)}
}

func (_c *MockClient_UpdateClient_Call) Run(run func(ctx context.Context, client *dto.Client)) *MockClient_UpdateClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*dto.Client))
	})
	return _c
}

func (_c *MockClient_UpdateClient_Call) Return(_a0 error) *MockClient_UpdateClient_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_UpdateClient_Call) RunAndReturn(run func(context.Context, *dto.Client) error) *MockClient_UpdateClient_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateClientScope provides a mock function with given fields: ctx, realmName, scopeID, scope
func (_m *MockClient) UpdateClientScope(ctx context.Context, realmName string, scopeID string, scope *adapter.ClientScope) error {
	ret := _m.Called(ctx, realmName, scopeID, scope)

	if len(ret) == 0 {
		panic("no return value specified for UpdateClientScope")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *adapter.ClientScope) error); ok {
		r0 = rf(ctx, realmName, scopeID, scope)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_UpdateClientScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateClientScope'
type MockClient_UpdateClientScope_Call struct {
	*mock.Call
}

// UpdateClientScope is a helper method to define mock.On call
//   - ctx context.Context
//   - realmName string
//   - scopeID string
//   - scope *adapter.ClientScope
func (_e *MockClient_Expecter) UpdateClientScope(ctx interface{}, realmName interface{}, scopeID interface{}, scope interface{}) *MockClient_UpdateClientScope_Call {
	return &MockClient_UpdateClientScope_Call{Call: _e.mock.On("UpdateClientScope", ctx, realmName, scopeID, scope)}
}

func (_c *MockClient_UpdateClientScope_Call) Run(run func(ctx context.Context, realmName string, scopeID string, scope *adapter.ClientScope)) *MockClient_UpdateClientScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*adapter.ClientScope))
	})
	return _c
}

func (_c *MockClient_UpdateClientScope_Call) Return(_a0 error) *MockClient_UpdateClientScope_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_UpdateClientScope_Call) RunAndReturn(run func(context.Context, string, string, *adapter.ClientScope) error) *MockClient_UpdateClientScope_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateComponent provides a mock function with given fields: ctx, realmName, component
func (_m *MockClient) UpdateComponent(ctx context.Context, realmName string, component *adapter.Component) error {
	ret := _m.Called(ctx, realmName, component)

	if len(ret) == 0 {
		panic("no return value specified for UpdateComponent")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *adapter.Component) error); ok {
		r0 = rf(ctx, realmName, component)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_UpdateComponent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateComponent'
type MockClient_UpdateComponent_Call struct {
	*mock.Call
}

// UpdateComponent is a helper method to define mock.On call
//   - ctx context.Context
//   - realmName string
//   - component *adapter.Component
func (_e *MockClient_Expecter) UpdateComponent(ctx interface{}, realmName interface{}, component interface{}) *MockClient_UpdateComponent_Call {
	return &MockClient_UpdateComponent_Call{Call: _e.mock.On("UpdateComponent", ctx, realmName, component)}
}

func (_c *MockClient_UpdateComponent_Call) Run(run func(ctx context.Context, realmName string, component *adapter.Component)) *MockClient_UpdateComponent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*adapter.Component))
	})
	return _c
}

func (_c *MockClient_UpdateComponent_Call) Return(_a0 error) *MockClient_UpdateComponent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_UpdateComponent_Call) RunAndReturn(run func(context.Context, string, *adapter.Component) error) *MockClient_UpdateComponent_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateIDPMapper provides a mock function with given fields: ctx, realm, idpAlias, mapper
func (_m *MockClient) UpdateIDPMapper(ctx context.Context, realm string, idpAlias string, mapper *adapter.IdentityProviderMapper) error {
	ret := _m.Called(ctx, realm, idpAlias, mapper)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIDPMapper")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *adapter.IdentityProviderMapper) error); ok {
		r0 = rf(ctx, realm, idpAlias, mapper)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_UpdateIDPMapper_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateIDPMapper'
type MockClient_UpdateIDPMapper_Call struct {
	*mock.Call
}

// UpdateIDPMapper is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idpAlias string
//   - mapper *adapter.IdentityProviderMapper
func (_e *MockClient_Expecter) UpdateIDPMapper(ctx interface{}, realm interface{}, idpAlias interface{}, mapper interface{}) *MockClient_UpdateIDPMapper_Call {
	return &MockClient_UpdateIDPMapper_Call{Call: _e.mock.On("UpdateIDPMapper", ctx, realm, idpAlias, mapper)}
}

func (_c *MockClient_UpdateIDPMapper_Call) Run(run func(ctx context.Context, realm string, idpAlias string, mapper *adapter.IdentityProviderMapper)) *MockClient_UpdateIDPMapper_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*adapter.IdentityProviderMapper))
	})
	return _c
}

func (_c *MockClient_UpdateIDPMapper_Call) Return(_a0 error) *MockClient_UpdateIDPMapper_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_UpdateIDPMapper_Call) RunAndReturn(run func(context.Context, string, string, *adapter.IdentityProviderMapper) error) *MockClient_UpdateIDPMapper_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateIdentityProvider provides a mock function with given fields: ctx, realm, idp
func (_m *MockClient) UpdateIdentityProvider(ctx context.Context, realm string, idp *adapter.IdentityProvider) error {
	ret := _m.Called(ctx, realm, idp)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIdentityProvider")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *adapter.IdentityProvider) error); ok {
		r0 = rf(ctx, realm, idp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_UpdateIdentityProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateIdentityProvider'
type MockClient_UpdateIdentityProvider_Call struct {
	*mock.Call
}

// UpdateIdentityProvider is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idp *adapter.IdentityProvider
func (_e *MockClient_Expecter) UpdateIdentityProvider(ctx interface{}, realm interface{}, idp interface{}) *MockClient_UpdateIdentityProvider_Call {
	return &MockClient_UpdateIdentityProvider_Call{Call: _e.mock.On("UpdateIdentityProvider", ctx, realm, idp)}
}

func (_c *MockClient_UpdateIdentityProvider_Call) Run(run func(ctx context.Context, realm string, idp *adapter.IdentityProvider)) *MockClient_UpdateIdentityProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*adapter.IdentityProvider))
	})
	return _c
}

func (_c *MockClient_UpdateIdentityProvider_Call) Return(_a0 error) *MockClient_UpdateIdentityProvider_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_UpdateIdentityProvider_Call) RunAndReturn(run func(context.Context, string, *adapter.IdentityProvider) error) *MockClient_UpdateIdentityProvider_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePermission provides a mock function with given fields: ctx, realm, idOfClient, permission
func (_m *MockClient) UpdatePermission(ctx context.Context, realm string, idOfClient string, permission gocloak.PermissionRepresentation) error {
	ret := _m.Called(ctx, realm, idOfClient, permission)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePermission")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.PermissionRepresentation) error); ok {
		r0 = rf(ctx, realm, idOfClient, permission)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_UpdatePermission_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePermission'
type MockClient_UpdatePermission_Call struct {
	*mock.Call
}

// UpdatePermission is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idOfClient string
//   - permission gocloak.PermissionRepresentation
func (_e *MockClient_Expecter) UpdatePermission(ctx interface{}, realm interface{}, idOfClient interface{}, permission interface{}) *MockClient_UpdatePermission_Call {
	return &MockClient_UpdatePermission_Call{Call: _e.mock.On("UpdatePermission", ctx, realm, idOfClient, permission)}
}

func (_c *MockClient_UpdatePermission_Call) Run(run func(ctx context.Context, realm string, idOfClient string, permission gocloak.PermissionRepresentation)) *MockClient_UpdatePermission_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(gocloak.PermissionRepresentation))
	})
	return _c
}

func (_c *MockClient_UpdatePermission_Call) Return(_a0 error) *MockClient_UpdatePermission_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_UpdatePermission_Call) RunAndReturn(run func(context.Context, string, string, gocloak.PermissionRepresentation) error) *MockClient_UpdatePermission_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePolicy provides a mock function with given fields: ctx, realm, idOfClient, policy
func (_m *MockClient) UpdatePolicy(ctx context.Context, realm string, idOfClient string, policy gocloak.PolicyRepresentation) error {
	ret := _m.Called(ctx, realm, idOfClient, policy)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePolicy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, gocloak.PolicyRepresentation) error); ok {
		r0 = rf(ctx, realm, idOfClient, policy)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_UpdatePolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePolicy'
type MockClient_UpdatePolicy_Call struct {
	*mock.Call
}

// UpdatePolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - realm string
//   - idOfClient string
//   - policy gocloak.PolicyRepresentation
func (_e *MockClient_Expecter) UpdatePolicy(ctx interface{}, realm interface{}, idOfClient interface{}, policy interface{}) *MockClient_UpdatePolicy_Call {
	return &MockClient_UpdatePolicy_Call{Call: _e.mock.On("UpdatePolicy", ctx, realm, idOfClient, policy)}
}

func (_c *MockClient_UpdatePolicy_Call) Run(run func(ctx context.Context, realm string, idOfClient string, policy gocloak.PolicyRepresentation)) *MockClient_UpdatePolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(gocloak.PolicyRepresentation))
	})
	return _c
}

func (_c *MockClient_UpdatePolicy_Call) Return(_a0 error) *MockClient_UpdatePolicy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_UpdatePolicy_Call) RunAndReturn(run func(context.Context, string, string, gocloak.PolicyRepresentation) error) *MockClient_UpdatePolicy_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRealmSettings provides a mock function with given fields: realmName, realmSettings
func (_m *MockClient) UpdateRealmSettings(realmName string, realmSettings *adapter.RealmSettings) error {
	ret := _m.Called(realmName, realmSettings)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRealmSettings")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *adapter.RealmSettings) error); ok {
		r0 = rf(realmName, realmSettings)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_UpdateRealmSettings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRealmSettings'
type MockClient_UpdateRealmSettings_Call struct {
	*mock.Call
}

// UpdateRealmSettings is a helper method to define mock.On call
//   - realmName string
//   - realmSettings *adapter.RealmSettings
func (_e *MockClient_Expecter) UpdateRealmSettings(realmName interface{}, realmSettings interface{}) *MockClient_UpdateRealmSettings_Call {
	return &MockClient_UpdateRealmSettings_Call{Call: _e.mock.On("UpdateRealmSettings", realmName, realmSettings)}
}

func (_c *MockClient_UpdateRealmSettings_Call) Run(run func(realmName string, realmSettings *adapter.RealmSettings)) *MockClient_UpdateRealmSettings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*adapter.RealmSettings))
	})
	return _c
}

func (_c *MockClient_UpdateRealmSettings_Call) Return(_a0 error) *MockClient_UpdateRealmSettings_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_UpdateRealmSettings_Call) RunAndReturn(run func(string, *adapter.RealmSettings) error) *MockClient_UpdateRealmSettings_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockClient creates a new instance of MockClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockClient {
	mock := &MockClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
